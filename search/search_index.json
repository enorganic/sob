{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"sob","text":"<p><code>sob</code> is an object serialization/deserialization library intended to facilitate automated authoring of models for JSON web APIs which are readable and introspective, and to expedite data validation and integration testing.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install <code>sob</code> with pip:</p> <pre><code>pip3 install sob\n</code></pre>"},{"location":"#background-information","title":"Background Information","text":"<p>This library is developed in concert with, and in support of, the oapi library, which facilitates generating client libraries (\"SDKs\"), for web APIs, based on an Open API document. For niche use cases, <code>sob</code> remains a separate library, but the development roadmap and all feature requests should be viewed in the context of supporting the definition and validation of data as described by an Open API document.</p> <p>When authoring server-side code for your web API, I recommend pydantic. The <code>sob</code> library is designed primarily to support web API client data models, and for automated model module creation based on metadata generated either using sob.thesaurus or oapi.</p> <p>The name \"sob\" is not a profane acronym (in this case), it is a portmanteau of \"serial\" and \"object\". Originally, this library was named \"serial\", but was renamed with version 1 due to a namespace conflict with pyserial.</p>"},{"location":"contributing/","title":"Contributing to sob","text":"<p>Please note that you must have hatch installed prior to performing the following steps.</p>"},{"location":"contributing/#for-enorganic-contributors-and-code-owners","title":"For Enorganic Contributors and Code Owners","text":"<ol> <li> <p>Clone and Install</p> <p>To install this project for development of this library, clone this repository (replacing \"~/Code\", below, with the directory under which you want your project to reside), then run <code>make</code>:</p> <pre><code>cd ~/Code &amp;&amp; \\\ngit clone\\\nhttps://github.com/enorganic/sob.git sob &amp;&amp; \\\ncd sob &amp;&amp; \\\nmake\n</code></pre> </li> <li> <p>Create a new branch for your changes (replacing \"descriptive-branch-name\"     with a descriptive branch name, and replacing feature with bugfix     if the branch addresses a bug):</p> <pre><code>git branch feature/descriptive-branch-name\n</code></pre> </li> <li> <p>Make some changes.</p> </li> <li> <p>Format and lint your code:</p> <pre><code>make format\n</code></pre> </li> <li> <p>Test your changes:</p> <pre><code>make test\n</code></pre> </li> <li> <p>Push your changes and create a pull request.</p> </li> </ol>"},{"location":"contributing/#for-everyone-else","title":"For Everyone Else","text":"<p>If you are not a contributor on this project, you can still create pull requests, however you will need to fork this project, push changes to your fork, and create a pull request from your forked repository.</p>"},{"location":"api/abc/","title":"sob.abc","text":""},{"location":"api/abc/#sob.abc","title":"sob.abc","text":"<p>This module contains abstract base classes declaring the interface for classes defined in <code>sob.model</code>, <code>sob.properties</code>, <code>sob.types</code>, <code>sob.meta</code>, and <code>sob.hooks</code>.</p>"},{"location":"api/abc/#sob.abc.Types","title":"Types","text":"<pre><code>Types(\n    items: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | None\n    ) = None,\n)\n</code></pre> <p>This class is an abstract base for <code>sob.Types</code>.</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    items: Iterable[type | Property] | type | Property | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.MutableTypes","title":"MutableTypes","text":"<pre><code>MutableTypes(\n    items: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Types</code></p> <p>This class is an abstract base for <code>sob.MutableTypes</code>.</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    items: Iterable[type | Property] | type | Property | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.Hooks","title":"Hooks","text":"<pre><code>Hooks(\n    before_marshal: (\n        typing.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    after_marshal: (\n        typing.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    before_unmarshal: (\n        typing.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    after_unmarshal: (\n        typing.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    before_serialize: (\n        typing.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    after_serialize: (\n        typing.Callable[[str], str] | None\n    ) = None,\n    before_validate: (\n        typing.Callable[[sob.abc.Model], sob.abc.Model]\n        | None\n    ) = None,\n    after_validate: (\n        typing.Callable[[sob.abc.Model], None] | None\n    ) = None,\n)\n</code></pre> <p>This class is an abstract base for <code>sob.Hooks</code>.</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    before_marshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    after_marshal: Callable[[JSONTypes], JSONTypes] | None = None,\n    before_unmarshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    after_unmarshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    before_serialize: Callable[[JSONTypes], JSONTypes] | None = None,\n    after_serialize: Callable[[str], str] | None = None,\n    before_validate: Callable[[Model], Model] | None = None,\n    after_validate: Callable[[Model], None] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.ObjectHooks","title":"ObjectHooks","text":"<pre><code>ObjectHooks(\n    before_marshal: (\n        typing.Callable[\n            [sob.abc.MarshallableTypes], typing.Any\n        ]\n        | None\n    ) = None,\n    after_marshal: (\n        typing.Callable[[sob.abc.JSONTypes], typing.Any]\n        | None\n    ) = None,\n    before_unmarshal: (\n        typing.Callable[\n            [sob.abc.MarshallableTypes], typing.Any\n        ]\n        | None\n    ) = None,\n    after_unmarshal: (\n        typing.Callable[\n            [sob.abc.MarshallableTypes], typing.Any\n        ]\n        | None\n    ) = None,\n    before_serialize: (\n        typing.Callable[[sob.abc.JSONTypes], typing.Any]\n        | None\n    ) = None,\n    after_serialize: (\n        typing.Callable[[str], str] | None\n    ) = None,\n    before_validate: (\n        typing.Callable[[sob.abc.Model], sob.abc.Model]\n        | None\n    ) = None,\n    after_validate: (\n        typing.Callable[[sob.abc.Model], None] | None\n    ) = None,\n    before_setattr: (\n        typing.Callable[\n            [\n                sob.abc.Object,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            tuple[str, sob.abc.MarshallableTypes],\n        ]\n        | None\n    ) = None,\n    after_setattr: (\n        typing.Callable[\n            [\n                sob.abc.Object,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            None,\n        ]\n        | None\n    ) = None,\n    before_setitem: (\n        typing.Callable[\n            [\n                sob.abc.Object,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            tuple[str, sob.abc.MarshallableTypes],\n        ]\n        | None\n    ) = None,\n    after_setitem: (\n        typing.Callable[\n            [\n                sob.abc.Object,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            None,\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Hooks</code></p> <p>This class is an abstract base for <code>sob.ObjectHooks</code>.</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    before_marshal: Callable[[MarshallableTypes], Any] | None = None,\n    after_marshal: Callable[[JSONTypes], Any] | None = None,\n    before_unmarshal: Callable[[MarshallableTypes], Any] | None = None,\n    after_unmarshal: Callable[[MarshallableTypes], Any] | None = None,\n    before_serialize: Callable[[JSONTypes], Any] | None = None,\n    after_serialize: Callable[[str], str] | None = None,\n    before_validate: Callable[[Model], Model] | None = None,\n    after_validate: Callable[[Model], None] | None = None,\n    before_setattr: Callable[\n        [Object, str, MarshallableTypes], tuple[str, MarshallableTypes]\n    ]\n    | None = None,\n    after_setattr: Callable[[Object, str, MarshallableTypes], None]\n    | None = None,\n    before_setitem: Callable[\n        [Object, str, MarshallableTypes], tuple[str, MarshallableTypes]\n    ]\n    | None = None,\n    after_setitem: Callable[[Object, str, MarshallableTypes], None]\n    | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.ArrayHooks","title":"ArrayHooks","text":"<pre><code>ArrayHooks(\n    before_marshal: (\n        typing.Callable[\n            [sob.abc.MarshallableTypes], typing.Any\n        ]\n        | None\n    ) = None,\n    after_marshal: (\n        typing.Callable[[sob.abc.JSONTypes], typing.Any]\n        | None\n    ) = None,\n    before_unmarshal: (\n        typing.Callable[\n            [sob.abc.MarshallableTypes], typing.Any\n        ]\n        | None\n    ) = None,\n    after_unmarshal: (\n        typing.Callable[\n            [sob.abc.MarshallableTypes], typing.Any\n        ]\n        | None\n    ) = None,\n    before_serialize: (\n        typing.Callable[[sob.abc.JSONTypes], typing.Any]\n        | None\n    ) = None,\n    after_serialize: (\n        typing.Callable[[str], str] | None\n    ) = None,\n    before_validate: (\n        typing.Callable[[sob.abc.Model], sob.abc.Model]\n        | None\n    ) = None,\n    after_validate: (\n        typing.Callable[[sob.abc.Model], None] | None\n    ) = None,\n    before_setitem: (\n        typing.Callable[\n            [sob.abc.Array, int, sob.abc.MarshallableTypes],\n            tuple[int, typing.Any],\n        ]\n        | None\n    ) = None,\n    after_setitem: (\n        typing.Callable[\n            [sob.abc.Array, int, sob.abc.MarshallableTypes],\n            None,\n        ]\n        | None\n    ) = None,\n    before_append: (\n        typing.Callable[\n            [sob.abc.Array, sob.abc.MarshallableTypes],\n            typing.Any | None,\n        ]\n        | None\n    ) = None,\n    after_append: (\n        typing.Callable[\n            [sob.abc.Array, sob.abc.MarshallableTypes], None\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Hooks</code></p> <p>This class is an abstract base for <code>sob.ArrayHooks</code>.</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    before_marshal: Callable[[MarshallableTypes], Any] | None = None,\n    after_marshal: Callable[[JSONTypes], Any] | None = None,\n    before_unmarshal: Callable[[MarshallableTypes], Any] | None = None,\n    after_unmarshal: Callable[[MarshallableTypes], Any] | None = None,\n    before_serialize: Callable[[JSONTypes], Any] | None = None,\n    after_serialize: Callable[[str], str] | None = None,\n    before_validate: Callable[[Model], Model] | None = None,\n    after_validate: Callable[[Model], None] | None = None,\n    before_setitem: Callable[\n        [Array, int, MarshallableTypes], tuple[int, Any]\n    ]\n    | None = None,\n    after_setitem: Callable[[Array, int, MarshallableTypes], None]\n    | None = None,\n    before_append: Callable[[Array, MarshallableTypes], Any | None]\n    | None = None,\n    after_append: Callable[[Array, MarshallableTypes], None] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.DictionaryHooks","title":"DictionaryHooks","text":"<pre><code>DictionaryHooks(\n    before_marshal: (\n        typing.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    after_marshal: (\n        typing.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    before_unmarshal: (\n        typing.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    after_unmarshal: (\n        typing.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    before_serialize: (\n        typing.Callable[[sob.abc.JSONTypes], typing.Any]\n        | None\n    ) = None,\n    after_serialize: (\n        typing.Callable[[str], str] | None\n    ) = None,\n    before_validate: (\n        typing.Callable[[sob.abc.Model], sob.abc.Model]\n        | None\n    ) = None,\n    after_validate: (\n        typing.Callable[[sob.abc.Model], None] | None\n    ) = None,\n    before_setitem: (\n        typing.Callable[\n            [\n                sob.abc.Dictionary,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            tuple[str, typing.Any],\n        ]\n        | None\n    ) = None,\n    after_setitem: (\n        typing.Callable[\n            [\n                sob.abc.Dictionary,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            None,\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Hooks</code></p> <p>This class is an abstract base for <code>sob.DictionaryHooks</code> .</p> Source code in <code>src/sob/abc.py</code> <pre><code>def __init__(\n    self,\n    before_marshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    after_marshal: Callable[[JSONTypes], JSONTypes] | None = None,\n    before_unmarshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    after_unmarshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    before_serialize: Callable[[JSONTypes], Any] | None = None,\n    after_serialize: Callable[[str], str] | None = None,\n    before_validate: Callable[[Model], Model] | None = None,\n    after_validate: Callable[[Model], None] | None = None,\n    before_setitem: Callable[\n        [Dictionary, str, MarshallableTypes], tuple[str, Any]\n    ]\n    | None = None,\n    after_setitem: Callable[[Dictionary, str, MarshallableTypes], None]\n    | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.Readable","title":"Readable","text":"<p>This is an abstract base for file-like objects which are readable, but not necessarily writable (such an which are found in the <code>io</code> module, but also objects such as <code>http.client.HTTPResponse</code>). Objects will be identified as sub-classes if they have a callable <code>read</code> method.</p>"},{"location":"api/abc/#sob.abc.Meta","title":"Meta","text":"<p>This class is an abstract base for <code>sob.Meta</code>.</p>"},{"location":"api/abc/#sob.abc.ObjectMeta","title":"ObjectMeta","text":"<pre><code>ObjectMeta(\n    properties: (\n        collections.abc.Mapping[str, sob.abc.Property]\n        | collections.abc.Iterable[\n            tuple[str, sob.abc.Property]\n        ]\n        | sob.abc.Properties\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Meta</code></p> <p>This class is an abstract base for <code>sob.ObjectMeta</code>.</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    properties: Mapping[str, Property]\n    | Iterable[tuple[str, Property]]\n    | Properties\n    | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.DictionaryMeta","title":"DictionaryMeta","text":"<pre><code>DictionaryMeta(\n    value_types: (\n        collections.abc.Iterable[sob.abc.Property | type]\n        | sob.abc.Types\n        | None\n        | sob.abc.Property\n        | type\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Meta</code></p> <p>This class is an abstract base for <code>sob.DictionaryMeta</code>.</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    value_types: Iterable[Property | type]\n    | Types\n    | None\n    | Property\n    | type = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.ArrayMeta","title":"ArrayMeta","text":"<pre><code>ArrayMeta(\n    item_types: (\n        collections.abc.Iterable[sob.abc.Property | type]\n        | sob.abc.Types\n        | None\n        | sob.abc.Property\n        | type\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Meta</code></p> <p>This class is an abstract base for <code>sob.ArrayMeta</code>.</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    item_types: Iterable[Property | type]\n    | Types\n    | None\n    | Property\n    | type = None,\n):\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.Properties","title":"Properties","text":"<pre><code>Properties(\n    items: (\n        collections.abc.Mapping[str, sob.abc.Property]\n        | collections.abc.Iterable[\n            tuple[str, sob.abc.Property]\n        ]\n        | sob.abc.Properties\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Meta</code></p> <p>This class is an abstract base for <code>sob.Properties</code>.</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    items: Mapping[str, Property]\n    | Iterable[tuple[str, Property]]\n    | Properties\n    | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.Model","title":"Model","text":"<p>This class is an abstract base for <code>sob.Model</code>.</p>"},{"location":"api/abc/#sob.abc.Dictionary","title":"Dictionary","text":"<pre><code>Dictionary(\n    items: (\n        sob.abc.Dictionary\n        | collections.abc.Mapping[\n            str, sob.abc.MarshallableTypes\n        ]\n        | collections.abc.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | str\n        | bytes\n        | None\n    ) = None,\n    value_types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | sob.abc.Types\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Model</code></p> <p>This class is an abstract base for <code>sob.Dictionary</code>.</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    items: Dictionary\n    | Mapping[str, MarshallableTypes]\n    | Iterable[tuple[str, MarshallableTypes]]\n    | Readable\n    | str\n    | bytes\n    | None = None,\n    value_types: Iterable[type | Property]\n    | type\n    | Property\n    | Types\n    | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.Object","title":"Object","text":"<pre><code>Object(\n    _data: (\n        sob.abc.Object\n        | sob.abc.Dictionary\n        | collections.abc.Mapping[\n            str, sob.abc.MarshallableTypes\n        ]\n        | collections.abc.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | str\n        | bytes\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Model</code></p> <p>This class is an abstract base for <code>sob.Object</code>.</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    _data: Object\n    | Dictionary\n    | Mapping[str, MarshallableTypes]\n    | Iterable[tuple[str, MarshallableTypes]]\n    | Readable\n    | str\n    | bytes\n    | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.Array","title":"Array","text":"<pre><code>Array(\n    items: (\n        sob.abc.Array\n        | collections.abc.Iterable[\n            sob.abc.MarshallableTypes\n        ]\n        | str\n        | bytes\n        | sob.abc.Readable\n        | None\n    ) = None,\n    item_types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | sob.abc.Types\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Model</code></p> <p>This class is an abstract base for <code>sob.Array</code>.</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    items: Array\n    | Iterable[MarshallableTypes]\n    | str\n    | bytes\n    | Readable\n    | None = None,\n    item_types: Iterable[type | Property]\n    | type\n    | Property\n    | Types\n    | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.Property","title":"Property","text":"<pre><code>Property(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | typing.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>This class is an abstract base for <code>sob.Property</code>.</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.StringProperty","title":"StringProperty","text":"<pre><code>StringProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | typing.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.StringProperty</code> .</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.DateProperty","title":"DateProperty","text":"<pre><code>DateProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | typing.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.DateProperty</code> .</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.DateTimeProperty","title":"DateTimeProperty","text":"<pre><code>DateTimeProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | typing.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.DateTimeProperty</code> .</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.BytesProperty","title":"BytesProperty","text":"<pre><code>BytesProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | typing.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.BytesProperty</code> .</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.EnumeratedProperty","title":"EnumeratedProperty","text":"<pre><code>EnumeratedProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | typing.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.EnumeratedProperty</code> .</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.NumberProperty","title":"NumberProperty","text":"<pre><code>NumberProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | typing.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.NumberProperty</code> .</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.IntegerProperty","title":"IntegerProperty","text":"<pre><code>IntegerProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | typing.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.IntegerProperty</code> .</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.BooleanProperty","title":"BooleanProperty","text":"<pre><code>BooleanProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | typing.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.BooleanProperty</code> .</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.ArrayProperty","title":"ArrayProperty","text":"<pre><code>ArrayProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | typing.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.ArrayProperty</code> .</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.DictionaryProperty","title":"DictionaryProperty","text":"<pre><code>DictionaryProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | typing.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.DictionaryProperty</code> .</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/abc/#sob.abc.Version","title":"Version","text":"<pre><code>Version(\n    version_number: str | None = None,\n    specification: str | None = None,\n    equals: (\n        collections.abc.Sequence[\n            str | float | int | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    not_equals: (\n        collections.abc.Sequence[\n            str | float | int | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    less_than: (\n        collections.abc.Sequence[\n            str | float | int | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    less_than_or_equal_to: (\n        collections.abc.Sequence[\n            str | float | int | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    greater_than: (\n        collections.abc.Sequence[\n            str | float | int | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    greater_than_or_equal_to: (\n        collections.abc.Sequence[\n            str | float | int | decimal.Decimal\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>This class is an abstract base for <code>sob.Version</code> .</p> Source code in <code>src/sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    version_number: str | None = None,\n    specification: str | None = None,\n    equals: Sequence[str | float | int | Decimal] | None = None,\n    not_equals: Sequence[str | float | int | Decimal] | None = None,\n    less_than: Sequence[str | float | int | Decimal] | None = None,\n    less_than_or_equal_to: Sequence[str | float | int | Decimal]\n    | None = None,\n    greater_than: Sequence[str | float | int | Decimal] | None = None,\n    greater_than_or_equal_to: Sequence[str | float | int | Decimal]\n    | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/errors/","title":"sob.errors","text":""},{"location":"api/errors/#sob.errors","title":"sob.errors","text":""},{"location":"api/errors/#sob.errors.DefinitionExistsError","title":"DefinitionExistsError","text":"<p>               Bases: <code>Exception</code></p> <p>This error is raised when an attempt is made to redefine a singleton class instance.</p>"},{"location":"api/errors/#sob.errors.ValidationError","title":"ValidationError","text":"<p>               Bases: <code>Exception</code></p> <p>This error is raised when <code>sob.validate</code> encounters extraneous attributes associated with a model instance, or discovers missing required attributes.</p>"},{"location":"api/errors/#sob.errors.VersionError","title":"VersionError","text":"<p>               Bases: <code>AttributeError</code></p> <p>This error is raised when versioning an object fails due to having data which is incompatible with the target version.</p>"},{"location":"api/errors/#sob.errors.DeserializeError","title":"DeserializeError","text":"<pre><code>DeserializeError(data: str | bytes, message: str = '')\n</code></pre> <p>               Bases: <code>ValueError</code></p> <p>This error is raised when data is encountered during deserialization which cannot be parsed.</p> <p>Attributes:</p> <ul> <li> <code>data</code>               (<code>str | bytes</code>)           \u2013            <p>The data that could not be parsed.</p> </li> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>Additional information about the error.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>str | bytes</code>)           \u2013            <p>The data that could not be parsed.</p> </li> <li> <code>message</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>An optional message to include with the error.</p> </li> </ul> Source code in <code>src/sob/errors.py</code> <pre><code>def __init__(self, data: str | bytes, message: str = \"\") -&gt; None:\n    \"\"\"\n    Parameters:\n        data: The data that could not be parsed.\n        message: An optional message to include with the error.\n    \"\"\"\n    self.data: str | bytes = data\n    self.message: str = message\n    super().__init__(*((data,) + ((message,) if message else ())))\n</code></pre>"},{"location":"api/errors/#sob.errors.UnmarshalError","title":"UnmarshalError","text":"<pre><code>UnmarshalError(\n    message: str | None = None,\n    data: sob.abc.MarshallableTypes | None = None,\n    types: (\n        collections.abc.Iterable[sob.abc.Property | type]\n        | sob.abc.Types\n        | None\n    ) = None,\n    item_types: (\n        collections.abc.Iterable[sob.abc.Property | type]\n        | sob.abc.Types\n        | None\n    ) = None,\n    value_types: (\n        collections.abc.Iterable[sob.abc.Property | type]\n        | sob.abc.Types\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>This is an error message raised when data cannot be un-marshalled due to not matching metadata specs.</p> <p>Attributes:</p> <ul> <li> <code>message</code>           \u2013            </li> <li> <code>parameter</code>           \u2013            </li> </ul> Source code in <code>src/sob/errors.py</code> <pre><code>def __init__(\n    self,\n    message: str | None = None,\n    data: abc.MarshallableTypes | None = None,\n    types: Iterable[abc.Property | type] | abc.Types | None = None,\n    item_types: Iterable[abc.Property | type] | abc.Types | None = None,\n    value_types: Iterable[abc.Property | type] | abc.Types | None = None,\n) -&gt; None:\n    error_message_lines: list[str] = []\n    # Identify which parameter is being used for type validation\n    types_label: str = (\n        \"item_types\"\n        if item_types\n        else \"value_types\"\n        if value_types\n        else \"types\"\n    )\n    types = item_types or value_types or types\n    if types is None:\n        error_message_lines.append(\n            \"The data provided is not an instance of an un-marshallable \"\n            \"type:\\n\"\n        )\n    else:\n        error_message_lines.append(\n            \"The data provided does not match any of the expected types \"\n            \"and/or property definitions:\\n\"\n        )\n    error_message_lines.append(f\"- data: {indent(represent(data))}\")\n    if types is None:\n        types = abc.MARSHALLABLE_TYPES\n        types_label = \"un-marshallable types\"\n    type_representation: str = indent(\n        represent(tuple(types)), number_of_spaces=2\n    )\n    error_message_lines.append(f\"- {types_label}: {type_representation}\")\n    if message:\n        error_message_lines += [\"\", message]\n    super().__init__(\"\\n\".join(error_message_lines))\n</code></pre>"},{"location":"api/errors/#sob.errors.get_exception_text","title":"get_exception_text","text":"<pre><code>get_exception_text() -&gt; str\n</code></pre> <p>When called within an exception, this function returns a text representation of the error matching what is found in <code>traceback.print_exception</code>, but is returned as a string value rather than printing.</p> Source code in <code>src/sob/errors.py</code> <pre><code>def get_exception_text() -&gt; str:\n    \"\"\"\n    When called within an exception, this function returns a text\n    representation of the error matching what is found in\n    `traceback.print_exception`, but is returned as a string value rather than\n    printing.\n    \"\"\"\n    return \"\".join(format_exception(*sys.exc_info()))\n</code></pre>"},{"location":"api/errors/#sob.errors.append_exception_text","title":"append_exception_text","text":"<pre><code>append_exception_text(\n    error: Exception, message: str\n) -&gt; None\n</code></pre> <p>Cause <code>message</code> to be appended to an error's exception text.</p> Source code in <code>src/sob/errors.py</code> <pre><code>def append_exception_text(error: Exception, message: str) -&gt; None:\n    \"\"\"\n    Cause `message` to be appended to an error's exception text.\n    \"\"\"\n    attribute_name: str\n    for attribute_name in (\"strerror\", \"msg\", \"errmsg\"):\n        attribute_value: str = getattr(error, attribute_name, \"\")\n        if attribute_value:\n            setattr(error, attribute_name, f\"{attribute_value}{message}\")\n    found: bool = False\n    index: int\n    arg: Any\n    reversed_args: list[Any] = list(reversed(error.args)) or [\"\"]\n    for index, value in enumerate(reversed_args):\n        if isinstance(value, str):\n            found = True\n            reversed_args[index] = f\"{value}{message}\"\n            break\n    if found:\n        error.args = tuple(reversed(reversed_args))\n    else:\n        error.args = (message,)\n</code></pre>"},{"location":"api/hooks/","title":"sob.hooks","text":""},{"location":"api/hooks/#sob.hooks","title":"sob.hooks","text":""},{"location":"api/hooks/#sob.hooks.Hooks","title":"Hooks","text":"<pre><code>Hooks(\n    before_marshal: (\n        typing.Callable[[sob.abc.Model], sob.abc.Model]\n        | None\n    ) = None,\n    after_marshal: (\n        typing.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    before_unmarshal: (\n        typing.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    after_unmarshal: (\n        typing.Callable[[sob.abc.Model], sob.abc.Model]\n        | None\n    ) = None,\n    before_serialize: (\n        typing.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    after_serialize: (\n        typing.Callable[[str], str] | None\n    ) = None,\n    before_validate: (\n        typing.Callable[[sob.abc.Model], sob.abc.Model]\n        | None\n    ) = None,\n    after_validate: (\n        typing.Callable[[sob.abc.Model], None] | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Hooks</code></p> <p>Instances of this class hold functions (\"hooks\") to be executed at various points during marshalling, un-marshalling, serializing, de-serializing or validation.</p> <p>Please note the following context-specific definitions:</p> <ul> <li>marshal: To convert an instance of an <code>sob.Model</code> sub-class into data     suitable for serializing with <code>json.dumps</code>. For example, marshalling     an instance of <code>sob.Dictionary</code>, or marshalling an instance of a     sub-class of <code>sob.Object</code>, would result in a <code>dict</code> object.</li> <li>unmarshal: To convert data de-serialized using <code>json.loads</code> into an     instance of an <code>sob.Model</code> sub-class. For example, un-marshalling a     <code>dict</code> object could return in an instance of <code>sob.Dictionary</code>     (this would be the default if no types were specified), or could     return an instance of one of the <code>sob.Model</code> sub-classes     specified in the <code>types</code> parameter passed to <code>sob.unmarshal</code>.</li> <li>serialize: To convert a marshalled object into a JSON string.</li> <li>deserialize: To convert a JSON string into a python-native object.</li> <li>validate: To check that the data held by a model instance is in     compliance with that model's metadata. Because data types are     enforced when attributes are set, validation only entails verifying     that all required attributes are present, and that no extraneous     attributes are present. Validation is only initiated explicitly,     by passing a model instance to the <code>sob.validate</code> function.</li> </ul> <p>Attributes:</p> <ul> <li> <code>before_marshal</code>           \u2013            <p>A function called before marshalling a model. The <code>before_marshal</code> function should accept deserialized JSON data (pre-marshalling) as the first argument, and return the same type of data (or <code>None</code>) as the return value.</p> </li> <li> <code>after_marshal</code>           \u2013            <p>A function to be called after marshalling a model. The <code>after_marshal</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>before_unmarshal</code>           \u2013            <p>A function to be called before un-marshalling a model. The <code>before_unmarshal</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>after_unmarshal</code>           \u2013            <p>A function to be called after un-marshalling a model. The <code>after_unmarshal</code> function should accept unmarshalled, but pre-serialized, JSON serializable data as the first argument, and return the same type of data (or <code>None</code>) as the return value.</p> </li> <li> <code>before_serialize</code>           \u2013            <p>A function to be called before serializing a model. The <code>before_serialize</code> function should accept unmarshalled, but pre-serialized, JSON serializable data as the first argument, and return the same type of data (or <code>None</code>) as the return value. For most use cases, assigning a function to <code>after_unmarshal</code> and to <code>before_serialize</code> will produce the same result, however it is technically possible to unmarshal data without ever serializing it, so both hooks are provided.</p> </li> <li> <code>after_serialize</code>           \u2013            <p>A function to be called after serializing a model. The <code>after_serialize</code> function should accept a JSON string as the only argument, and return a JSON string as the return value.</p> </li> <li> <code>before_validate</code>           \u2013            <p>A function to be called before validating a model. The <code>before_validate</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>after_validate</code>           \u2013            <p>A function to be called after validating a model. The <code>after_validate</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> </ul> Source code in <code>src/sob/hooks.py</code> <pre><code>def __init__(\n    self,\n    before_marshal: Callable[[abc.Model], abc.Model] | None = None,\n    after_marshal: Callable[[JSONTypes], JSONTypes] | None = None,\n    before_unmarshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    after_unmarshal: Callable[[abc.Model], abc.Model] | None = None,\n    before_serialize: Callable[[JSONTypes], JSONTypes] | None = None,\n    after_serialize: Callable[[str], str] | None = None,\n    before_validate: Callable[[abc.Model], abc.Model] | None = None,\n    after_validate: Callable[[abc.Model], None] | None = None,\n):\n    self.before_marshal = before_marshal\n    self.after_marshal = after_marshal\n    self.before_unmarshal = before_unmarshal\n    self.after_unmarshal = after_unmarshal\n    self.before_serialize = before_serialize\n    self.after_serialize = after_serialize\n    self.before_validate = before_validate\n    self.after_validate = after_validate\n</code></pre>"},{"location":"api/hooks/#sob.hooks.ObjectHooks","title":"ObjectHooks","text":"<pre><code>ObjectHooks(\n    before_marshal: (\n        typing.Callable[[sob.abc.Model], sob.abc.Model]\n        | None\n    ) = None,\n    after_marshal: (\n        typing.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    before_unmarshal: (\n        typing.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    after_unmarshal: (\n        typing.Callable[[sob.abc.Model], sob.abc.Model]\n        | None\n    ) = None,\n    before_serialize: (\n        typing.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    after_serialize: (\n        typing.Callable[[str], str] | None\n    ) = None,\n    before_validate: (\n        typing.Callable[[sob.abc.Model], sob.abc.Model]\n        | None\n    ) = None,\n    after_validate: (\n        typing.Callable[[sob.abc.Model], None] | None\n    ) = None,\n    before_setattr: (\n        typing.Callable[\n            [\n                sob.abc.Object,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            tuple[str, sob.abc.MarshallableTypes],\n        ]\n        | None\n    ) = None,\n    after_setattr: (\n        typing.Callable[\n            [\n                sob.abc.Object,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            None,\n        ]\n        | None\n    ) = None,\n    before_setitem: (\n        typing.Callable[\n            [\n                sob.abc.Object,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            tuple[str, sob.abc.MarshallableTypes],\n        ]\n        | None\n    ) = None,\n    after_setitem: (\n        typing.Callable[\n            [\n                sob.abc.Object,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            None,\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.hooks.Hooks</code>, <code>sob.abc.ObjectHooks</code></p> <p>Instances of this class hold functions (\"hooks\") to be executed at various points during marshalling, un-marshalling, serializing, de-serializing or validation.</p> <p>Please note the following context-specific definitions:</p> <ul> <li>marshal: To convert an instance of an <code>sob.Model</code> sub-class into data     suitable for serializing with <code>json.dumps</code>. For example, marshalling     an instance of <code>sob.Dictionary</code>, or marshalling an instance of a     sub-class of <code>sob.Object</code>, would result in a <code>dict</code> object.</li> <li>unmarshal: To convert data de-serialized using <code>json.loads</code> into an     instance of an <code>sob.Model</code> sub-class. For example, un-marshalling a     <code>dict</code> object could return in an instance of <code>sob.Dictionary</code>     (this would be the default if no types were specified), or could     return an instance of one of the <code>sob.Model</code> sub-classes     specified in the <code>types</code> parameter passed to <code>sob.unmarshal</code>.</li> <li>serialize: To convert a marshalled object into a JSON string.</li> <li>deserialize: To convert a JSON string into a python-native object.</li> <li>validate: To check that the data held by a model instance is in     compliance with that model's metadata. Because data types are     enforced when attributes are set, validation only entails verifying     that all required attributes are present, and that no extraneous     attributes are present. Validation is only initiated explicitly,     by passing a model instance to the <code>sob.validate</code> function.</li> </ul> <p>Attributes:</p> <ul> <li> <code>before_marshal</code>           \u2013            <p>A function called before marshalling a model. The <code>before_marshal</code> function should accept deserialized JSON data (pre-marshalling) as the first argument, and return the same type of data (or <code>None</code>) as the return value.</p> </li> <li> <code>after_marshal</code>           \u2013            <p>A function to be called after marshalling a model. The <code>after_marshal</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>before_unmarshal</code>           \u2013            <p>A function to be called before un-marshalling a model. The <code>before_unmarshal</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>after_unmarshal</code>           \u2013            <p>A function to be called after un-marshalling a model. The <code>after_unmarshal</code> function should accept unmarshalled, but pre-serialized, JSON serializable data as the first argument, and return the same type of data (or <code>None</code>) as the return value.</p> </li> <li> <code>before_serialize</code>           \u2013            <p>A function to be called before serializing a model. The <code>before_serialize</code> function should accept unmarshalled, but pre-serialized, JSON serializable data as the first argument, and return the same type of data (or <code>None</code>) as the return value. For most use cases, assigning a function to <code>after_unmarshal</code> and to <code>before_serialize</code> will produce the same result, however it is technically possible to unmarshal data without ever serializing it, so both hooks are provided.</p> </li> <li> <code>after_serialize</code>           \u2013            <p>A function to be called after serializing a model. The <code>after_serialize</code> function should accept a JSON string as the only argument, and return a JSON string as the return value.</p> </li> <li> <code>before_validate</code>           \u2013            <p>A function to be called before validating a model. The <code>before_validate</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>after_validate</code>           \u2013            <p>A function to be called after validating a model. The <code>after_validate</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>before_setattr</code>           \u2013            <p>A function to be called before setting an attribute. The <code>before_setattr</code> function should accept 3 positional arguments: an instance of the class to which it is associated, the attribute name, and the value to be assigned to that attribute. The function should return a tuple containing an attribute name and a value to be assigned to that attribute.</p> </li> <li> <code>after_setattr</code>           \u2013            <p>A function to be called after setting an attribute. The <code>after_setattr</code> function should accept 3 positional arguments: an instance of the class to which it is associated, the attribute name, and the value assigned to that attribute. The function should return <code>None</code>.</p> </li> <li> <code>before_setitem</code>           \u2013            <p>A function to be called before assigning a value to an object by key. The <code>before_setitem</code> function should accept 3 positional arguments: an instance of the class to which it is associated, the item key, and the value to be assigned to that key. The function should return a tuple containing a key and a value to be assigned.</p> </li> <li> <code>after_setitem</code>           \u2013            <p>A function to be called after assigning a value to an object by key. The <code>before_setitem</code> function should accept 3 positional arguments: an instance of the class to which it is associated, the item key, and the value assigned to that key. The function should return <code>None</code>.</p> </li> </ul> Source code in <code>src/sob/hooks.py</code> <pre><code>def __init__(\n    self,\n    before_marshal: Callable[[abc.Model], abc.Model] | None = None,\n    after_marshal: Callable[[JSONTypes], JSONTypes] | None = None,\n    before_unmarshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    after_unmarshal: Callable[[abc.Model], abc.Model] | None = None,\n    before_serialize: Callable[[JSONTypes], JSONTypes] | None = None,\n    after_serialize: Callable[[str], str] | None = None,\n    before_validate: Callable[[abc.Model], abc.Model] | None = None,\n    after_validate: Callable[[abc.Model], None] | None = None,\n    before_setattr: Callable[\n        [abc.Object, str, MarshallableTypes], tuple[str, MarshallableTypes]\n    ]\n    | None = None,\n    after_setattr: Callable[[abc.Object, str, MarshallableTypes], None]\n    | None = None,\n    before_setitem: Callable[\n        [abc.Object, str, MarshallableTypes], tuple[str, MarshallableTypes]\n    ]\n    | None = None,\n    after_setitem: Callable[[abc.Object, str, MarshallableTypes], None]\n    | None = None,\n) -&gt; None:\n    super().__init__(\n        before_marshal=before_marshal,\n        after_marshal=after_marshal,\n        before_unmarshal=before_unmarshal,\n        after_unmarshal=after_unmarshal,\n        before_serialize=before_serialize,\n        after_serialize=after_serialize,\n        before_validate=before_validate,\n        after_validate=after_validate,\n    )\n    self.before_setattr = before_setattr\n    self.after_setattr = after_setattr\n    self.before_setitem = before_setitem\n    self.after_setitem = after_setitem\n</code></pre>"},{"location":"api/hooks/#sob.hooks.ArrayHooks","title":"ArrayHooks","text":"<pre><code>ArrayHooks(\n    before_marshal: (\n        typing.Callable[[sob.abc.Model], sob.abc.Model]\n        | None\n    ) = None,\n    after_marshal: (\n        typing.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    before_unmarshal: (\n        typing.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    after_unmarshal: (\n        typing.Callable[[sob.abc.Model], sob.abc.Model]\n        | None\n    ) = None,\n    before_serialize: (\n        typing.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    after_serialize: (\n        typing.Callable[[str], str] | None\n    ) = None,\n    before_validate: (\n        typing.Callable[[sob.abc.Model], sob.abc.Model]\n        | None\n    ) = None,\n    after_validate: (\n        typing.Callable[[sob.abc.Model], None] | None\n    ) = None,\n    before_setitem: (\n        typing.Callable[\n            [sob.abc.Array, int, sob.abc.MarshallableTypes],\n            tuple[int, sob.abc.MarshallableTypes],\n        ]\n        | None\n    ) = None,\n    after_setitem: (\n        typing.Callable[\n            [sob.abc.Array, int, sob.abc.MarshallableTypes],\n            None,\n        ]\n        | None\n    ) = None,\n    before_append: (\n        typing.Callable[\n            [sob.abc.Array, sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    after_append: (\n        typing.Callable[\n            [sob.abc.Array, sob.abc.MarshallableTypes], None\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.hooks.Hooks</code>, <code>sob.abc.ArrayHooks</code></p> <p>Instances of this class hold functions (\"hooks\") to be executed at various points during marshalling, un-marshalling, serializing, de-serializing or validation.</p> <p>Please note the following context-specific definitions:</p> <ul> <li>marshal: To convert an instance of an <code>sob.Model</code> sub-class into data     suitable for serializing with <code>json.dumps</code>. For example, marshalling     an instance of <code>sob.Dictionary</code>, or marshalling an instance of a     sub-class of <code>sob.Object</code>, would result in a <code>dict</code> object.</li> <li>unmarshal: To convert data de-serialized using <code>json.loads</code> into an     instance of an <code>sob.Model</code> sub-class. For example, un-marshalling a     <code>dict</code> object could return in an instance of <code>sob.Dictionary</code>     (this would be the default if no types were specified), or could     return an instance of one of the <code>sob.Model</code> sub-classes     specified in the <code>types</code> parameter passed to <code>sob.unmarshal</code>.</li> <li>serialize: To convert a marshalled object into a JSON string.</li> <li>deserialize: To convert a JSON string into a python-native object.</li> <li>validate: To check that the data held by a model instance is in     compliance with that model's metadata. Because data types are     enforced when attributes are set, validation only entails verifying     that all required attributes are present, and that no extraneous     attributes are present. Validation is only initiated explicitly,     by passing a model instance to the <code>sob.validate</code> function.</li> </ul> <p>Attributes:</p> <ul> <li> <code>before_marshal</code>           \u2013            <p>A function called before marshalling a model. The <code>before_marshal</code> function should accept deserialized JSON data (pre-marshalling) as the first argument, and return the same type of data (or <code>None</code>) as the return value.</p> </li> <li> <code>after_marshal</code>           \u2013            <p>A function to be called after marshalling a model. The <code>after_marshal</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>before_unmarshal</code>           \u2013            <p>A function to be called before un-marshalling a model. The <code>before_unmarshal</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>after_unmarshal</code>           \u2013            <p>A function to be called after un-marshalling a model. The <code>after_unmarshal</code> function should accept unmarshalled, but pre-serialized, JSON serializable data as the first argument, and return the same type of data (or <code>None</code>) as the return value.</p> </li> <li> <code>before_serialize</code>           \u2013            <p>A function to be called before serializing a model. The <code>before_serialize</code> function should accept unmarshalled, but pre-serialized, JSON serializable data as the first argument, and return the same type of data (or <code>None</code>) as the return value. For most use cases, assigning a function to <code>after_unmarshal</code> and to <code>before_serialize</code> will produce the same result, however it is technically possible to unmarshal data without ever serializing it, so both hooks are provided.</p> </li> <li> <code>after_serialize</code>           \u2013            <p>A function to be called after serializing a model. The <code>after_serialize</code> function should accept a JSON string as the only argument, and return a JSON string as the return value.</p> </li> <li> <code>before_validate</code>           \u2013            <p>A function to be called before validating a model. The <code>before_validate</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>after_validate</code>           \u2013            <p>A function to be called after validating a model. The <code>after_validate</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>before_setitem</code>           \u2013            <p>A function to be called before assigning a value to an object by index. The <code>before_setitem</code> function should accept 3 positional arguments: an instance of the class to which it is associated, the index, and the value to be assigned to that index position. The function should return a tuple containing an index and a value to be assigned to that position.</p> </li> <li> <code>after_setitem</code>           \u2013            <p>A function to be called after assigning a value to an object by index. The <code>before_setitem</code> function should accept 3 positional arguments: an instance of the class to which it is associated, the index, and the value assigned to that position. The function should return <code>None</code>.</p> </li> <li> <code>before_append</code>           \u2013            <p>A function to be called before appending a value to the array. The <code>before_append</code> function should accept 2 positional arguments: an instance of the class to which it is associated, and the value to be appended. The function should return the value to be appended.</p> </li> <li> <code>after_append</code>           \u2013            <p>A function to be called after appending a value to the array. The <code>after_append</code> function should accept 2 positional arguments: an instance of the class to which it is associated, and the value appended. The function should return <code>None</code>.</p> </li> </ul> Source code in <code>src/sob/hooks.py</code> <pre><code>def __init__(\n    self,\n    before_marshal: Callable[[abc.Model], abc.Model] | None = None,\n    after_marshal: Callable[[JSONTypes], JSONTypes] | None = None,\n    before_unmarshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    after_unmarshal: Callable[[abc.Model], abc.Model] | None = None,\n    before_serialize: Callable[[JSONTypes], JSONTypes] | None = None,\n    after_serialize: Callable[[str], str] | None = None,\n    before_validate: Callable[[abc.Model], abc.Model] | None = None,\n    after_validate: Callable[[abc.Model], None] | None = None,\n    before_setitem: Callable[\n        [abc.Array, int, MarshallableTypes], tuple[int, MarshallableTypes]\n    ]\n    | None = None,\n    after_setitem: Callable[[abc.Array, int, MarshallableTypes], None]\n    | None = None,\n    before_append: Callable[\n        [abc.Array, MarshallableTypes], MarshallableTypes\n    ]\n    | None = None,\n    after_append: Callable[[abc.Array, MarshallableTypes], None]\n    | None = None,\n) -&gt; None:\n    super().__init__(\n        before_marshal=before_marshal,\n        after_marshal=after_marshal,\n        before_unmarshal=before_unmarshal,\n        after_unmarshal=after_unmarshal,\n        before_serialize=before_serialize,\n        after_serialize=after_serialize,\n        before_validate=before_validate,\n        after_validate=after_validate,\n    )\n    self.before_setitem = before_setitem\n    self.after_setitem = after_setitem\n    self.before_append = before_append\n    self.after_append = after_append\n</code></pre>"},{"location":"api/hooks/#sob.hooks.DictionaryHooks","title":"DictionaryHooks","text":"<pre><code>DictionaryHooks(\n    before_marshal: (\n        typing.Callable[[sob.abc.Model], sob.abc.Model]\n        | None\n    ) = None,\n    after_marshal: (\n        typing.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    before_unmarshal: (\n        typing.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    after_unmarshal: (\n        typing.Callable[[sob.abc.Model], sob.abc.Model]\n        | None\n    ) = None,\n    before_serialize: (\n        typing.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    after_serialize: (\n        typing.Callable[[str], str] | None\n    ) = None,\n    before_validate: (\n        typing.Callable[[sob.abc.Model], sob.abc.Model]\n        | None\n    ) = None,\n    after_validate: (\n        typing.Callable[[sob.abc.Model], None] | None\n    ) = None,\n    before_setitem: (\n        typing.Callable[\n            [\n                sob.abc.Dictionary,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            tuple[str, sob.abc.MarshallableTypes],\n        ]\n        | None\n    ) = None,\n    after_setitem: (\n        typing.Callable[\n            [\n                sob.abc.Dictionary,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            None,\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.hooks.Hooks</code>, <code>sob.abc.DictionaryHooks</code></p> <p>Instances of this class hold functions (\"hooks\") to be executed at various points during marshalling, un-marshalling, serializing, de-serializing or validation.</p> <p>Please note the following context-specific definitions:</p> <ul> <li>marshal: To convert an instance of an <code>sob.Dictionary</code> sub-class into     data suitable for serializing with <code>json.dumps</code>. For example,     marshalling an instance of <code>sob.Dictionary</code> would result in a <code>dict</code>     object.</li> <li>unmarshal: To convert data de-serialized using <code>json.loads</code> into an     instance of an <code>sob.Model</code> sub-class. For example, un-marshalling a     <code>dict</code> object could return in an instance of <code>sob.Dictionary</code>     (this would be the default if no types were specified), or could     return an instance of one of the <code>sob.Model</code> sub-classes     specified in the <code>types</code> parameter passed to <code>sob.unmarshal</code>.</li> <li>serialize: To convert a marshalled object into a JSON string.</li> <li>deserialize: To convert a JSON string into a python-native object.</li> <li>validate: To check that the data held by a model instance is in     compliance with that model's metadata. Because data types are     enforced when attributes are set, validation only entails verifying     that all required attributes are present, and that no extraneous     attributes are present. Validation is only initiated explicitly,     by passing a model instance to the <code>sob.validate</code> function.</li> </ul> <p>Attributes:</p> <ul> <li> <code>before_marshal</code>           \u2013            <p>A function called before marshalling a model. The <code>before_marshal</code> function should accept deserialized JSON data (pre-marshalling) as the first argument, and return the same type of data (or <code>None</code>) as the return value.</p> </li> <li> <code>after_marshal</code>           \u2013            <p>A function to be called after marshalling a model. The <code>after_marshal</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>before_unmarshal</code>           \u2013            <p>A function to be called before un-marshalling a model. The <code>before_unmarshal</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>after_unmarshal</code>           \u2013            <p>A function to be called after un-marshalling a model. The <code>after_unmarshal</code> function should accept unmarshalled, but pre-serialized, JSON serializable data as the first argument, and return the same type of data (or <code>None</code>) as the return value.</p> </li> <li> <code>before_serialize</code>           \u2013            <p>A function to be called before serializing a model. The <code>before_serialize</code> function should accept unmarshalled, but pre-serialized, JSON serializable data as the first argument, and return the same type of data (or <code>None</code>) as the return value. For most use cases, assigning a function to <code>after_unmarshal</code> and to <code>before_serialize</code> will produce the same result, however it is technically possible to unmarshal data without ever serializing it, so both hooks are provided.</p> </li> <li> <code>after_serialize</code>           \u2013            <p>A function to be called after serializing a model. The <code>after_serialize</code> function should accept a JSON string as the only argument, and return a JSON string as the return value.</p> </li> <li> <code>before_validate</code>           \u2013            <p>A function to be called before validating a model. The <code>before_validate</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>after_validate</code>           \u2013            <p>A function to be called after validating a model. The <code>after_validate</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>before_setitem</code>           \u2013            <p>A function to be called before assigning a value to an object by key. The <code>before_setitem</code> function should accept 3 positional arguments: an instance of the class to which it is associated, the item key, and the value to be assigned to that key. The function should return a tuple containing a key and a value to be assigned.</p> </li> <li> <code>after_setitem</code>           \u2013            <p>A function to be called after assigning a value to an object by key. The <code>before_setitem</code> function should accept 3 positional arguments: an instance of the class to which it is associated, the item key, and the value assigned to that key. The function should return <code>None</code>.</p> </li> </ul> Source code in <code>src/sob/hooks.py</code> <pre><code>def __init__(\n    self,\n    before_marshal: Callable[[abc.Model], abc.Model] | None = None,\n    after_marshal: Callable[[JSONTypes], JSONTypes] | None = None,\n    before_unmarshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    after_unmarshal: Callable[[abc.Model], abc.Model] | None = None,\n    before_serialize: Callable[[JSONTypes], JSONTypes] | None = None,\n    after_serialize: Callable[[str], str] | None = None,\n    before_validate: Callable[[abc.Model], abc.Model] | None = None,\n    after_validate: Callable[[abc.Model], None] | None = None,\n    before_setitem: Callable[\n        [abc.Dictionary, str, MarshallableTypes],\n        tuple[str, MarshallableTypes],\n    ]\n    | None = None,\n    after_setitem: Callable[[abc.Dictionary, str, MarshallableTypes], None]\n    | None = None,\n):\n    super().__init__(\n        before_marshal=before_marshal,\n        after_marshal=after_marshal,\n        before_unmarshal=before_unmarshal,\n        after_unmarshal=after_unmarshal,\n        before_serialize=before_serialize,\n        after_serialize=after_serialize,\n        before_validate=before_validate,\n        after_validate=after_validate,\n    )\n    self.before_setitem = before_setitem\n    self.after_setitem = after_setitem\n</code></pre>"},{"location":"api/hooks/#sob.hooks.read_model_hooks","title":"read_model_hooks","text":"<pre><code>read_model_hooks(\n    model: type | sob.abc.Model,\n) -&gt; sob.abc.Hooks | None\n</code></pre> <p>Read the hooks associated with a sub-class or instance of <code>sob.Model</code>, or return <code>None</code> if no hooks are defined.</p> <p>Please note that the returned hooks may be inherited, and therefore should not be modified. Use <code>get_writable_model_hooks</code> to retrieve an instance of these hooks suitable for modification.</p> Source code in <code>src/sob/hooks.py</code> <pre><code>def read_model_hooks(model: type | abc.Model) -&gt; abc.Hooks | None:\n    \"\"\"\n    Read the hooks associated with a sub-class or instance of `sob.Model`,\n    or return `None` if no hooks are defined.\n\n    Please note that the returned hooks may be inherited,\n    and therefore should not be modified. Use `get_writable_model_hooks` to\n    retrieve an instance of these hooks suitable for modification.\n    \"\"\"\n    message: str\n    if isinstance(model, abc.Model):\n        return getattr(model, \"_instance_hooks\", None) or read_model_hooks(\n            type(model)\n        )\n    if isinstance(model, type) and issubclass(model, abc.Model):\n        base: type\n        try:\n            return next(\n                getattr(base, \"_class_hooks\", None)\n                for base in filter(\n                    lambda base: issubclass(base, abc.Model),\n                    model.__mro__,\n                )\n            )\n        except StopIteration:\n            return None\n    repr_model: str = repr(model)\n    message = (\n        \"{} requires a parameter which is an instance or sub-class of \"\n        \"`{}`, not{}\".format(\n            get_calling_function_qualified_name(),\n            get_qualified_name(abc.Model),\n            (f\":\\n{repr_model}\" if \"\\n\" in repr_model else f\" `{repr_model}`\"),\n        )\n    )\n    raise TypeError(message)\n</code></pre>"},{"location":"api/hooks/#sob.hooks.read_object_hooks","title":"read_object_hooks","text":"<pre><code>read_object_hooks(\n    model: type | sob.abc.Object,\n) -&gt; sob.abc.ObjectHooks | None\n</code></pre> <p>Read the hooks associated with a sub-class or instance of <code>sob.Object</code>, or return <code>None</code> if no hooks are defined.</p> <p>Please note that the returned hooks may be inherited, and therefore should not be modified. Use <code>get_writable_object_hooks</code> to retrieve an instance of these hooks suitable for modification.</p> Source code in <code>src/sob/hooks.py</code> <pre><code>def read_object_hooks(model: type | abc.Object) -&gt; abc.ObjectHooks | None:\n    \"\"\"\n    Read the hooks associated with a sub-class or instance of `sob.Object`,\n    or return `None` if no hooks are defined.\n\n    Please note that the returned hooks may be inherited,\n    and therefore should not be modified. Use `get_writable_object_hooks` to\n    retrieve an instance of these hooks suitable for modification.\n    \"\"\"\n    return read_model_hooks(model)  # type: ignore\n</code></pre>"},{"location":"api/hooks/#sob.hooks.read_array_hooks","title":"read_array_hooks","text":"<pre><code>read_array_hooks(\n    model: type | sob.abc.Array,\n) -&gt; sob.abc.ArrayHooks | None\n</code></pre> <p>Read the hooks associated with a sub-class or instance of <code>sob.Array</code>, or return <code>None</code> if no hooks are defined.</p> <p>Please note that the returned hooks may be inherited, and therefore should not be modified. Use <code>get_writable_array_hooks</code> to retrieve an instance of these hooks suitable for modification.</p> Source code in <code>src/sob/hooks.py</code> <pre><code>def read_array_hooks(model: type | abc.Array) -&gt; abc.ArrayHooks | None:\n    \"\"\"\n    Read the hooks associated with a sub-class or instance of `sob.Array`,\n    or return `None` if no hooks are defined.\n\n    Please note that the returned hooks may be inherited,\n    and therefore should not be modified. Use\n    `get_writable_array_hooks` to retrieve an instance of these hooks\n    suitable for modification.\n    \"\"\"\n    return read_model_hooks(model)  # type: ignore\n</code></pre>"},{"location":"api/hooks/#sob.hooks.read_dictionary_hooks","title":"read_dictionary_hooks","text":"<pre><code>read_dictionary_hooks(\n    model: type | sob.abc.Dictionary,\n) -&gt; sob.abc.DictionaryHooks | None\n</code></pre> <p>Read hooks from a sub-class or instance of <code>sob.Dictionary</code>.</p> <p>Please note that the returned hooks may be inherited, and therefore should not be modified. Use <code>get_writable_dictionary_hooks</code> to retrieve an instance of these hooks suitable for modification.</p> Source code in <code>src/sob/hooks.py</code> <pre><code>def read_dictionary_hooks(\n    model: type | abc.Dictionary,\n) -&gt; abc.DictionaryHooks | None:\n    \"\"\"\n    Read hooks from a sub-class or instance of `sob.Dictionary`.\n\n    Please note that the returned hooks may be inherited,\n    and therefore should not be modified. Use `get_writable_dictionary_hooks`\n    to retrieve an instance of these hooks suitable for modification.\n    \"\"\"\n    return read_model_hooks(model)  # type: ignore\n</code></pre>"},{"location":"api/hooks/#sob.hooks.get_writable_model_hooks","title":"get_writable_model_hooks","text":"<pre><code>get_writable_model_hooks(\n    model: type[sob.abc.Model] | sob.abc.Model,\n) -&gt; sob.abc.Hooks\n</code></pre> <p>Retrieve an instance of <code>sob.Hooks</code> which is associated directly with the <code>model</code> class or instance, and therefore suitable for modifying.</p> <p>If <code>model</code> is an instance of an <code>sob.Model</code> sub-class, and the instance does not have any hooks associated, the class hooks will be copied to the instance and returned.</p> <p>If <code>model</code> is a sub-class of <code>sob.Model</code>, but does not have any hooks associated, hooks will be copied from the first parent class which has hooks attributed, and the copy will be returned.</p> <p>If neither the <code>model</code> class or instance, nor any parent classes, have any hooks associated\u2014a new instance of <code>sob.Hooks</code> will be created, attributed to <code>model</code>, and returned.</p> Source code in <code>src/sob/hooks.py</code> <pre><code>def get_writable_model_hooks(model: type[abc.Model] | abc.Model) -&gt; abc.Hooks:\n    \"\"\"\n    Retrieve an instance of `sob.Hooks` which is associated directly with the\n    `model` class or instance, and therefore suitable for modifying.\n\n    If `model` is an instance of an `sob.Model` sub-class, and the instance\n    does not have any hooks associated, the class hooks will be\n    copied to the instance and returned.\n\n    If `model` is a sub-class of `sob.Model`, but does not have any hooks\n    associated, hooks will be copied from the first parent class which\n    has hooks attributed, and the copy will be returned.\n\n    If neither the `model` class or instance, nor any parent classes,\n    have any hooks associated\u2014a new instance of `sob.Hooks` will be\n    created, attributed to `model`, and returned.\n    \"\"\"\n    if not _is_model(model):\n        raise TypeError(model)\n    if isinstance(model, abc.Model):\n        if model._instance_hooks is None:  # noqa: SLF001\n            model._instance_hooks = deepcopy(  # noqa: SLF001\n                read_model_hooks(type(model))\n            )\n        if model._instance_hooks is None:  # noqa: SLF001\n            model._instance_hooks = (  # noqa: SLF001\n                ObjectHooks()\n                if isinstance(model, abc.Object)\n                else ArrayHooks()\n                if isinstance(model, abc.Array)\n                else DictionaryHooks()\n            )\n        return model._instance_hooks  # noqa: SLF001\n    if isinstance(model, type) and issubclass(model, abc.Model):\n        if model._class_hooks is None:  # noqa: SLF001\n            model._class_hooks = deepcopy(  # noqa: SLF001\n                read_model_hooks(model)\n            )\n        if model._class_hooks is None:  # noqa: SLF001\n            model._class_hooks = (  # noqa: SLF001\n                ObjectHooks()\n                if issubclass(model, abc.Object)\n                else ArrayHooks()\n                if issubclass(model, abc.Array)\n                else DictionaryHooks()\n            )\n        return model._class_hooks  # noqa: SLF001\n    repr_model: str = represent(model)\n    message: str = (\n        \"{} requires a parameter which is an instance or sub-class of \"\n        \"`{}`, not{}\".format(\n            get_calling_function_qualified_name(),\n            get_qualified_name(abc.Model),\n            (\":\\n\" + repr_model if \"\\n\" in repr_model else f\" `{repr_model}`\"),\n        )\n    )\n    raise TypeError(message)\n</code></pre>"},{"location":"api/hooks/#sob.hooks.get_writable_object_hooks","title":"get_writable_object_hooks","text":"<pre><code>get_writable_object_hooks(\n    model: type | sob.abc.Object,\n) -&gt; sob.abc.ObjectHooks\n</code></pre> <p>Retrieve an instance of <code>sob.ObjectHooks</code> which is associated directly with the <code>model</code> class or instance, and therefore suitable for modifying.</p> <p>If <code>model</code> is an instance of an <code>sob.Object</code> sub-class, and the instance does not have any hooks associated, the class hooks will be copied to the instance and returned.</p> <p>If <code>model</code> is a sub-class of <code>sob.Object</code>, but does not have any hooks associated, hooks will be copied from the first parent class which has hooks attributed, and the copy will be returned.</p> <p>If neither the <code>model</code> class or instance, nor any parent classes, have any hooks associated\u2014a new instance of <code>sob.ObjectHooks</code> will be created, attributed to <code>model</code>, and returned.</p> Source code in <code>src/sob/hooks.py</code> <pre><code>def get_writable_object_hooks(model: type | abc.Object) -&gt; abc.ObjectHooks:\n    \"\"\"\n    Retrieve an instance of `sob.ObjectHooks` which is associated directly with\n    the `model` class or instance, and therefore suitable for modifying.\n\n    If `model` is an instance of an `sob.Object` sub-class, and the instance\n    does not have any hooks associated, the class hooks will be\n    copied to the instance and returned.\n\n    If `model` is a sub-class of `sob.Object`, but does not have any hooks\n    associated, hooks will be copied from the first parent class which\n    has hooks attributed, and the copy will be returned.\n\n    If neither the `model` class or instance, nor any parent classes,\n    have any hooks associated\u2014a new instance of `sob.ObjectHooks` will be\n    created, attributed to `model`, and returned.\n    \"\"\"\n    return get_writable_model_hooks(model)  # type: ignore\n</code></pre>"},{"location":"api/hooks/#sob.hooks.get_writable_array_hooks","title":"get_writable_array_hooks","text":"<pre><code>get_writable_array_hooks(\n    model: type | sob.abc.Array,\n) -&gt; sob.abc.ArrayHooks\n</code></pre> <p>Retrieve an instance of <code>sob.ArrayHooks</code> which is associated directly with the <code>model</code> class or instance, and therefore suitable for modifying.</p> <p>If <code>model</code> is an instance of an <code>sob.Array</code> sub-class, and the instance does not have any hooks associated, the class hooks will be copied to the instance and returned.</p> <p>If <code>model</code> is a sub-class of <code>sob.Array</code>, but does not have any hooks associated, hooks will be copied from the first parent class which has hooks attributed, and the copy will be returned.</p> <p>If neither the <code>model</code> class or instance, nor any parent classes, have any hooks associated\u2014a new instance of <code>sob.ArrayHooks</code> will be created, attributed to <code>model</code>, and returned.</p> Source code in <code>src/sob/hooks.py</code> <pre><code>def get_writable_array_hooks(model: type | abc.Array) -&gt; abc.ArrayHooks:\n    \"\"\"\n    Retrieve an instance of `sob.ArrayHooks` which is associated directly with\n    the `model` class or instance, and therefore suitable for modifying.\n\n    If `model` is an instance of an `sob.Array` sub-class, and the instance\n    does not have any hooks associated, the class hooks will be\n    copied to the instance and returned.\n\n    If `model` is a sub-class of `sob.Array`, but does not have any hooks\n    associated, hooks will be copied from the first parent class which\n    has hooks attributed, and the copy will be returned.\n\n    If neither the `model` class or instance, nor any parent classes,\n    have any hooks associated\u2014a new instance of `sob.ArrayHooks` will be\n    created, attributed to `model`, and returned.\n    \"\"\"\n    return get_writable_model_hooks(model)  # type: ignore\n</code></pre>"},{"location":"api/hooks/#sob.hooks.get_writable_dictionary_hooks","title":"get_writable_dictionary_hooks","text":"<pre><code>get_writable_dictionary_hooks(\n    model: type | sob.abc.Dictionary,\n) -&gt; sob.abc.DictionaryHooks\n</code></pre> <p>Retrieve an instance of <code>sob.DictionaryHooks</code> which is associated directly with the <code>model</code> class or instance, and therefore suitable for writing hooks to.</p> <p>If <code>model</code> is an instance of an <code>sob.Dictionary</code> sub-class, and the instance does not have any hooks associated, the parent class'es hooks will be copied to the instance and returned.</p> <p>If <code>model</code> is a sub-class of <code>sob.Dictionary</code>, but does not have any hooks associated, hooks will be copied from the first parent class which does have hooks attributed.</p> <p>If neither the <code>model</code> class or instance, nor any parent classes, have any hooks associated\u2014a new instance of <code>sob.DictionaryHooks</code> will be created, attributed to <code>model</code>, and returned.</p> Source code in <code>src/sob/hooks.py</code> <pre><code>def get_writable_dictionary_hooks(\n    model: type | abc.Dictionary,\n) -&gt; abc.DictionaryHooks:\n    \"\"\"\n    Retrieve an instance of `sob.DictionaryHooks` which is associated directly\n    with the `model` class or instance, and therefore suitable for writing\n    hooks to.\n\n    If `model` is an instance of an `sob.Dictionary` sub-class, and the\n    instance does not have any hooks associated, the parent class'es hooks will\n    be copied to the instance and returned.\n\n    If `model` is a sub-class of `sob.Dictionary`, but does not have any hooks\n    associated, hooks will be copied from the first parent class which does\n    have hooks attributed.\n\n    If neither the `model` class or instance, nor any parent classes,\n    have any hooks associated\u2014a new instance of `sob.DictionaryHooks` will be\n    created, attributed to `model`, and returned.\n    \"\"\"\n    return get_writable_model_hooks(model)  # type: ignore\n</code></pre>"},{"location":"api/hooks/#sob.hooks.get_model_hooks_type","title":"get_model_hooks_type","text":"<pre><code>get_model_hooks_type(model: type | sob.abc.Model) -&gt; type\n</code></pre> <p>Determine the type of metadata required for the specified <code>model</code> class or instance.</p> Source code in <code>src/sob/hooks.py</code> <pre><code>def get_model_hooks_type(model: type | abc.Model) -&gt; type:\n    \"\"\"\n    Determine the type of metadata required for the specified `model`\n    class or instance.\n    \"\"\"\n    hooks_type: type\n    if not isinstance(model, (type, abc.Object, abc.Dictionary, abc.Array)):\n        raise TypeError(model)\n    if isinstance(model, type):\n        if not issubclass(model, (abc.Object, abc.Dictionary, abc.Array)):\n            raise TypeError(model)\n        hooks_type = (\n            ObjectHooks\n            if issubclass(model, abc.Object)\n            else ArrayHooks\n            if issubclass(model, abc.Array)\n            else DictionaryHooks\n        )\n    else:\n        hooks_type = (\n            ObjectHooks\n            if isinstance(model, abc.Object)\n            else ArrayHooks\n            if isinstance(model, abc.Array)\n            else DictionaryHooks\n        )\n    return hooks_type\n</code></pre>"},{"location":"api/hooks/#sob.hooks.write_model_hooks","title":"write_model_hooks","text":"<pre><code>write_model_hooks(\n    model: type[sob.abc.Model] | sob.abc.Model,\n    hooks: sob.abc.Hooks | None,\n) -&gt; None\n</code></pre> <p>Write hooks to a sub-class or instance of <code>sob.Model</code>.</p> Source code in <code>src/sob/hooks.py</code> <pre><code>def write_model_hooks(\n    model: type[abc.Model] | abc.Model, hooks: abc.Hooks | None\n) -&gt; None:\n    \"\"\"\n    Write hooks to a sub-class or instance of `sob.Model`.\n    \"\"\"\n    if hooks is not None:\n        # Verify that the metadata is of the correct type\n        hooks_type: type[abc.Hooks] = get_model_hooks_type(model)\n        if not isinstance(hooks, hooks_type):\n            message: str = (\n                f\"Hooks assigned to `{get_qualified_name(type(model))}` \"\n                f\"must be of type `{get_qualified_name(hooks_type)}`\"\n            )\n            raise ValueError(message)\n    if isinstance(model, abc.Model):\n        model._instance_hooks = hooks  # noqa: SLF001\n    else:\n        if not issubclass(model, abc.Model):\n            raise TypeError(model)\n        model._class_hooks = hooks  # noqa: SLF001\n</code></pre>"},{"location":"api/meta/","title":"sob.meta","text":""},{"location":"api/meta/#sob.meta","title":"sob.meta","text":""},{"location":"api/meta/#sob.meta.Meta","title":"Meta","text":"<p>               Bases: <code>sob.abc.Meta</code></p> <p>This is a base class for <code>sob.ObjectMeta</code>, <code>sob.ArrayMeta</code>, and <code>sob.DictionaryMeta</code>, and implements methods common to these three classes.</p>"},{"location":"api/meta/#sob.meta.ObjectMeta","title":"ObjectMeta","text":"<pre><code>ObjectMeta(\n    properties: (\n        collections.abc.Mapping[str, sob.abc.Property]\n        | collections.abc.Iterable[\n            tuple[str, sob.abc.Property]\n        ]\n        | sob.abc.Properties\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.meta.Meta</code>, <code>sob.abc.ObjectMeta</code></p> <p>This class holds metadata for a sub-class or instance of <code>sob.Object</code>.</p> <p>Attributes:</p> <ul> <li> <code>properties</code>               (<code>sob.abc.Properties | None</code>)           \u2013            <p>This is a dictionary-like object mapping property names to a corresponding instance (or sub-class instance) of <code>sob.Property</code>  for a sub-class or sub-class instance of <code>sob.Object</code> . Attempting to set values for a property which do not correspond to the property metadata will raise a <code>TypeError</code>. Deserializing data with dictionary keys not corresponding to a defined property will not raise an error on deserializing, but will raise an <code>sob.ValidationError</code>  when/if the instance is validated using <code>sob.validate</code> .</p> </li> </ul> Source code in <code>src/sob/meta.py</code> <pre><code>def __init__(\n    self,\n    properties: Mapping[str, abc.Property]\n    | Iterable[tuple[str, abc.Property]]\n    | abc.Properties\n    | None = None,\n) -&gt; None:\n    self._properties: abc.Properties | None = None\n    self.properties = properties  # type: ignore\n</code></pre>"},{"location":"api/meta/#sob.meta.DictionaryMeta","title":"DictionaryMeta","text":"<pre><code>DictionaryMeta(\n    value_types: (\n        collections.abc.Iterable[sob.abc.Property | type]\n        | sob.abc.Types\n        | None\n        | sob.abc.Property\n        | type\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.meta.Meta</code>, <code>sob.abc.DictionaryMeta</code></p> <p>This class holds metadata for a sub-class or instance of <code>sob.Dictionary</code>.</p> <p>Attributes:</p> <ul> <li> <code>value_types</code>               (<code>sob.abc.Types | None</code>)           \u2013            <p>This is a sequence of types and/or instances of <code>sob.Property</code>  or one of its sub-classes determining the types of values which can be stored in a sub-class or sub-class instance of <code>sob.Dictionary</code> . Attempting to set values of a type not described by the dictionary value types will raise a <code>TypeError</code>.</p> </li> </ul> Source code in <code>src/sob/meta.py</code> <pre><code>def __init__(\n    self,\n    value_types: Iterable[abc.Property | type]\n    | abc.Types\n    | None\n    | abc.Property\n    | type = None,\n) -&gt; None:\n    self._value_types: abc.Types | None = None\n    self.value_types = value_types  # type: ignore\n</code></pre>"},{"location":"api/meta/#sob.meta.ArrayMeta","title":"ArrayMeta","text":"<pre><code>ArrayMeta(\n    item_types: (\n        collections.abc.Iterable[sob.abc.Property | type]\n        | sob.abc.Types\n        | None\n        | sob.abc.Property\n        | type\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.meta.Meta</code>, <code>sob.abc.ArrayMeta</code></p> <p>This class holds metadata for a sub-class or instance of <code>sob.Array</code>.</p> <p>Attributes:</p> <ul> <li> <code>item_types</code>               (<code>sob.abc.Types | None</code>)           \u2013            <p>This is a sequence of types and/or instances of <code>sob.Property</code>  or one of its sub-classes determining the types of items which can be stored in a sub-class or sub-class instance of <code>sob.Array</code> . Attempting to insert or append items of a type not described by the array item types will raise a <code>TypeError</code>.</p> </li> </ul> Source code in <code>src/sob/meta.py</code> <pre><code>def __init__(\n    self,\n    item_types: Iterable[abc.Property | type]\n    | abc.Types\n    | None\n    | abc.Property\n    | type = None,\n):\n    self._item_types: abc.Types | None = None\n    self.item_types = item_types  # type: ignore\n</code></pre>"},{"location":"api/meta/#sob.meta.Properties","title":"Properties","text":"<pre><code>Properties(\n    items: (\n        collections.abc.Mapping[str, sob.abc.Property]\n        | collections.abc.Iterable[\n            tuple[str, sob.abc.Property]\n        ]\n        | sob.abc.Properties\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Properties</code></p> <p>Instances of this class are dictionary-like objects mapping property names to a corresponding instance (or sub-class instance) of <code>sob.Property</code> .</p> Source code in <code>src/sob/meta.py</code> <pre><code>def __init__(\n    self,\n    items: Mapping[str, abc.Property]\n    | Iterable[tuple[str, abc.Property]]\n    | abc.Properties\n    | None = None,\n) -&gt; None:\n    self._dict: dict[str, abc.Property] = {}\n    if items is not None:\n        self.update(items)\n</code></pre>"},{"location":"api/meta/#sob.meta.read_model_meta","title":"read_model_meta","text":"<pre><code>read_model_meta(\n    model: type | sob.abc.Model,\n) -&gt; sob.abc.Meta | None\n</code></pre> <p>Read the metadata associated with a sub-class or instance of <code>sob.Model</code>, or return <code>None</code> if no metadata is defined.</p> <p>Please note that the returned metadata may be inherited, and therefore should not be modified. Use <code>get_writable_model_meta</code> to retrieve an instance of this metadata suitable for modification.</p> Source code in <code>src/sob/meta.py</code> <pre><code>def read_model_meta(model: type | abc.Model) -&gt; abc.Meta | None:\n    \"\"\"\n    Read the metadata associated with a sub-class or instance of `sob.Model`,\n    or return `None` if no metadata is defined.\n\n    Please note that the returned metadata may be inherited,\n    and therefore should not be modified. Use `get_writable_model_meta` to\n    retrieve an instance of this metadata suitable for modification.\n    \"\"\"\n    message: str\n    if isinstance(model, abc.Model):\n        return getattr(model, \"_instance_meta\", None) or read_model_meta(\n            type(model)\n        )\n    if isinstance(model, type) and issubclass(model, abc.Model):\n        base: type | None\n        try:\n            return next(\n                getattr(base, \"_class_meta\", None)\n                for base in filter(\n                    lambda base: issubclass(base, abc.Model),\n                    model.__mro__,\n                )\n            )\n        except StopIteration:\n            return None\n    repr_model: str = represent(model)\n    message = (\n        \"{} requires a parameter which is an instance or sub-class of \"\n        \"`{}`, not{}\".format(\n            get_calling_function_qualified_name(),\n            get_qualified_name(abc.Model),\n            (f\":\\n{repr_model}\" if \"\\n\" in repr_model else f\" `{repr_model}`\"),\n        )\n    )\n    raise TypeError(message)\n</code></pre>"},{"location":"api/meta/#sob.meta.read_object_meta","title":"read_object_meta","text":"<pre><code>read_object_meta(\n    model: type | sob.abc.Object,\n) -&gt; sob.abc.ObjectMeta | None\n</code></pre> <p>Read the metadata associated with a sub-class or instance of <code>sob.Object</code>, or return <code>None</code> if no metadata is defined.</p> <p>Please note that the returned metadata may be inherited, and therefore should not be modified. Use <code>get_writable_object_meta</code> to retrieve an instance of this metadata suitable for modification.</p> Source code in <code>src/sob/meta.py</code> <pre><code>def read_object_meta(model: type | abc.Object) -&gt; abc.ObjectMeta | None:\n    \"\"\"\n    Read the metadata associated with a sub-class or instance of `sob.Object`,\n    or return `None` if no metadata is defined.\n\n    Please note that the returned metadata may be inherited,\n    and therefore should not be modified. Use `get_writable_object_meta` to\n    retrieve an instance of this metadata suitable for modification.\n    \"\"\"\n    return read_model_meta(model)  # type: ignore\n</code></pre>"},{"location":"api/meta/#sob.meta.read_array_meta","title":"read_array_meta","text":"<pre><code>read_array_meta(\n    model: type | sob.abc.Array,\n) -&gt; sob.abc.ArrayMeta | None\n</code></pre> <p>Read the metadata associated with a sub-class or instance of <code>sob.Array</code>, or return <code>None</code> if no metadata is defined.</p> <p>Please note that the returned metadata may be inherited, and therefore should not be modified. Use <code>get_writable_array_meta</code> to retrieve an instance of this metadata suitable for modification.</p> Source code in <code>src/sob/meta.py</code> <pre><code>def read_array_meta(model: type | abc.Array) -&gt; abc.ArrayMeta | None:\n    \"\"\"\n    Read the metadata associated with a sub-class or instance of `sob.Array`,\n    or return `None` if no metadata is defined.\n\n    Please note that the returned metadata may be inherited,\n    and therefore should not be modified. Use `get_writable_array_meta` to\n    retrieve an instance of this metadata suitable for modification.\n    \"\"\"\n    return read_model_meta(model)  # type: ignore\n</code></pre>"},{"location":"api/meta/#sob.meta.read_dictionary_meta","title":"read_dictionary_meta","text":"<pre><code>read_dictionary_meta(\n    model: type[sob.abc.Dictionary] | sob.abc.Dictionary,\n) -&gt; sob.abc.DictionaryMeta | None\n</code></pre> <p>Read metadata from a sub-class or instance of <code>sob.Dictionary</code>.</p> <p>Please note that the returned metadata may be inherited, and therefore should not be modified. Use <code>get_writable_dictionary_hooks</code> to retrieve an instance of this metadata suitable for modification.</p> Source code in <code>src/sob/meta.py</code> <pre><code>def read_dictionary_meta(\n    model: type[abc.Dictionary] | abc.Dictionary,\n) -&gt; abc.DictionaryMeta | None:\n    \"\"\"\n    Read metadata from a sub-class or instance of `sob.Dictionary`.\n\n    Please note that the returned metadata may be inherited,\n    and therefore should not be modified. Use `get_writable_dictionary_hooks`\n    to retrieve an instance of this metadata suitable for modification.\n    \"\"\"\n    return read_model_meta(model)  # type: ignore\n</code></pre>"},{"location":"api/meta/#sob.meta.get_writable_model_meta","title":"get_writable_model_meta","text":"<pre><code>get_writable_model_meta(\n    model: type | sob.abc.Model,\n) -&gt; sob.abc.Meta\n</code></pre> <p>Retrieve an instance of <code>sob.Meta</code> which is associated directly with the <code>model</code> class or instance, and therefore suitable for modifying.</p> <p>If <code>model</code> is an instance of an <code>sob.Model</code> sub-class, and the instance does not have any metadata associated, the class hooks will be copied to the instance and returned</p> <p>If <code>model</code> is a sub-class of <code>sob.Model</code>, but does not have any metadata associated, hooks will be copied from the first parent class which has metadata attributed, and the copy will be returned.</p> <p>If neither the <code>model</code> class or instance, nor any parent classes, have any metadata associated\u2014a new instance of <code>sob.Meta</code> will be created, attributed to <code>model</code>, and returned.</p> Source code in <code>src/sob/meta.py</code> <pre><code>def get_writable_model_meta(model: type | abc.Model) -&gt; abc.Meta:\n    \"\"\"\n    Retrieve an instance of `sob.Meta` which is associated directly with the\n    `model` class or instance, and therefore suitable for modifying.\n\n    If `model` is an instance of an `sob.Model` sub-class, and the instance\n    does not have any metadata associated, the class hooks will be\n    copied to the instance and returned\n\n    If `model` is a sub-class of `sob.Model`, but does not have any metadata\n    associated, hooks will be copied from the first parent class which\n    has metadata attributed, and the copy will be returned.\n\n    If neither the `model` class or instance, nor any parent classes,\n    have any metadata associated\u2014a new instance of `sob.Meta` will be\n    created, attributed to `model`, and returned.\n    \"\"\"\n    if not _is_model(model):\n        raise TypeError(model)\n    if isinstance(model, abc.Model):\n        if model._instance_meta is None:  # noqa: SLF001\n            model._instance_meta = deepcopy(  # noqa: SLF001\n                read_model_meta(type(model))\n            )\n        if model._instance_meta is None:  # noqa: SLF001\n            model._instance_meta = (  # noqa: SLF001\n                ObjectMeta()\n                if isinstance(model, abc.Object)\n                else ArrayMeta()\n                if isinstance(model, abc.Array)\n                else DictionaryMeta()\n            )\n        return model._instance_meta  # noqa: SLF001\n    if isinstance(model, type) and issubclass(model, abc.Model):\n        if model._class_meta is None:  # noqa: SLF001\n            model._class_meta = deepcopy(  # noqa: SLF001\n                read_model_meta(model)\n            )\n        if model._class_meta is None:  # noqa: SLF001\n            model._class_meta = (  # noqa: SLF001\n                ObjectMeta()\n                if issubclass(model, abc.Object)\n                else ArrayMeta()\n                if issubclass(model, abc.Array)\n                else DictionaryMeta()\n            )\n        return model._class_meta  # noqa: SLF001\n    repr_model: str = represent(model)\n    message: str = (\n        \"{} requires a parameter which is an instance or sub-class of \"\n        \"`{}`, not{}\".format(\n            get_calling_function_qualified_name(),\n            get_qualified_name(abc.Model),\n            (\":\\n\" + repr_model if \"\\n\" in repr_model else f\" `{repr_model}`\"),\n        )\n    )\n    raise TypeError(message)\n</code></pre>"},{"location":"api/meta/#sob.meta.get_writable_object_meta","title":"get_writable_object_meta","text":"<pre><code>get_writable_object_meta(\n    object_: type[sob.abc.Object] | sob.abc.Object,\n) -&gt; sob.abc.ObjectMeta\n</code></pre> <p>Retrieve an instance of <code>sob.ObjectMeta</code> which is associated directly with the <code>model</code> class or instance, and therefore suitable for modifying.</p> <p>If <code>model</code> is an instance of an <code>sob.Object</code> sub-class, and the instance does not have any metadata associated, the class metadata will be copied to the instance and returned.</p> <p>If <code>model</code> is a sub-class of <code>sob.Object</code>, but does not have any metadata associated, metadata will be copied from the first parent class which has metadata attributed, and the copy will be returned.</p> <p>If neither the <code>model</code> class or instance, nor any parent classes, have any metadata associated\u2014a new instance of <code>sob.ObjectMeta</code> will be created, attributed to <code>model</code>, and returned.</p> Source code in <code>src/sob/meta.py</code> <pre><code>def get_writable_object_meta(\n    object_: type[abc.Object] | abc.Object,\n) -&gt; abc.ObjectMeta:\n    \"\"\"\n    Retrieve an instance of `sob.ObjectMeta` which is associated directly with\n    the `model` class or instance, and therefore suitable for modifying.\n\n    If `model` is an instance of an `sob.Object` sub-class, and the instance\n    does not have any metadata associated, the class metadata will be\n    copied to the instance and returned.\n\n    If `model` is a sub-class of `sob.Object`, but does not have any metadata\n    associated, metadata will be copied from the first parent class which\n    has metadata attributed, and the copy will be returned.\n\n    If neither the `model` class or instance, nor any parent classes,\n    have any metadata associated\u2014a new instance of `sob.ObjectMeta` will be\n    created, attributed to `model`, and returned.\n    \"\"\"\n    return get_writable_model_meta(object_)  # type: ignore\n</code></pre>"},{"location":"api/meta/#sob.meta.get_writable_array_meta","title":"get_writable_array_meta","text":"<pre><code>get_writable_array_meta(\n    model: type | sob.abc.Array,\n) -&gt; sob.abc.ArrayMeta\n</code></pre> <p>Retrieve an instance of <code>sob.ArrayMeta</code> which is associated directly with the <code>model</code> class or instance, and therefore suitable for modifying.</p> <p>If <code>model</code> is an instance of an <code>sob.Array</code> sub-class, and the instance does not have any metadata associated, the class metadata will be copied to the instance and returned.</p> <p>If <code>model</code> is a sub-class of <code>sob.Array</code>, but does not have any metadata associated, metadata will be copied from the first parent class which has metadata attributed, and the copy will be returned.</p> <p>If neither the <code>model</code> class or instance, nor any parent classes, have any metadata associated\u2014a new instance of <code>sob.ArrayMeta</code> will be created, attributed to <code>model</code>, and returned.</p> Source code in <code>src/sob/meta.py</code> <pre><code>def get_writable_array_meta(model: type | abc.Array) -&gt; abc.ArrayMeta:\n    \"\"\"\n    Retrieve an instance of `sob.ArrayMeta` which is associated directly with\n    the `model` class or instance, and therefore suitable for modifying.\n\n    If `model` is an instance of an `sob.Array` sub-class, and the instance\n    does not have any metadata associated, the class metadata will be\n    copied to the instance and returned.\n\n    If `model` is a sub-class of `sob.Array`, but does not have any metadata\n    associated, metadata will be copied from the first parent class which\n    has metadata attributed, and the copy will be returned.\n\n    If neither the `model` class or instance, nor any parent classes,\n    have any metadata associated\u2014a new instance of `sob.ArrayMeta` will be\n    created, attributed to `model`, and returned.\n    \"\"\"\n    return get_writable_model_meta(model)  # type: ignore\n</code></pre>"},{"location":"api/meta/#sob.meta.get_writable_dictionary_meta","title":"get_writable_dictionary_meta","text":"<pre><code>get_writable_dictionary_meta(\n    model: type | sob.abc.Dictionary,\n) -&gt; sob.abc.DictionaryMeta\n</code></pre> <p>Retrieve an instance of <code>sob.DictionaryMeta</code> which is associated directly with the <code>model</code> class or instance, and therefore suitable for writing metadata to.</p> <p>If <code>model</code> is an instance of an <code>sob.Dictionary</code> sub-class, and the instance does not have any metadata associated, the parent class metadata will be copied to the instance and returned.</p> <p>If <code>model</code> is a sub-class of <code>sob.Dictionary</code>, but does not have any metadata associated, metadata will be copied from the first parent class which does have metadata attributed.</p> <p>If neither the <code>model</code> class or instance, nor any parent classes, have any metadata associated\u2014a new instance of <code>sob.DictionaryMeta</code> will be created, attributed to <code>model</code>, and returned.</p> Source code in <code>src/sob/meta.py</code> <pre><code>def get_writable_dictionary_meta(\n    model: type | abc.Dictionary,\n) -&gt; abc.DictionaryMeta:\n    \"\"\"\n    Retrieve an instance of `sob.DictionaryMeta` which is associated directly\n    with the `model` class or instance, and therefore suitable for writing\n    metadata to.\n\n    If `model` is an instance of an `sob.Dictionary` sub-class, and the\n    instance does not have any metadata associated, the parent class metadata\n    will be copied to the instance and returned.\n\n    If `model` is a sub-class of `sob.Dictionary`, but does not have any\n    metadata associated, metadata will be copied from the first parent class\n    which does have metadata attributed.\n\n    If neither the `model` class or instance, nor any parent classes,\n    have any metadata associated\u2014a new instance of `sob.DictionaryMeta` will be\n    created, attributed to `model`, and returned.\n    \"\"\"\n    return get_writable_model_meta(model)  # type: ignore\n</code></pre>"},{"location":"api/meta/#sob.meta.get_model_meta_type","title":"get_model_meta_type","text":"<pre><code>get_model_meta_type(model: type | sob.abc.Model) -&gt; type\n</code></pre> <p>Determine the type of metadata required for the specified <code>model</code> class or instance.</p> Source code in <code>src/sob/meta.py</code> <pre><code>def get_model_meta_type(model: type | abc.Model) -&gt; type:\n    \"\"\"\n    Determine the type of metadata required for the specified `model`\n    class or instance.\n    \"\"\"\n    meta_type: type | None\n    if not isinstance(model, (type, abc.Object, abc.Dictionary, abc.Array)):\n        raise TypeError(model)\n    if isinstance(model, type):\n        if not issubclass(model, (abc.Object, abc.Dictionary, abc.Array)):\n            raise TypeError(model)\n        meta_type = (\n            ObjectMeta\n            if issubclass(model, abc.Object)\n            else ArrayMeta\n            if issubclass(model, abc.Array)\n            else DictionaryMeta\n        )\n    else:\n        meta_type = (\n            ObjectMeta\n            if isinstance(model, abc.Object)\n            else ArrayMeta\n            if isinstance(model, abc.Array)\n            else DictionaryMeta\n        )\n    return meta_type\n</code></pre>"},{"location":"api/meta/#sob.meta.write_model_meta","title":"write_model_meta","text":"<pre><code>write_model_meta(\n    model: type[sob.abc.Model] | sob.abc.Model,\n    meta: sob.abc.Meta | None,\n) -&gt; None\n</code></pre> <p>Write metadata to a sub-class or instance of <code>sob.Model</code>.</p> Source code in <code>src/sob/meta.py</code> <pre><code>def write_model_meta(\n    model: type[abc.Model] | abc.Model, meta: abc.Meta | None\n) -&gt; None:\n    \"\"\"\n    Write metadata to a sub-class or instance of `sob.Model`.\n    \"\"\"\n    if meta is not None:\n        # Verify that the metadata is of the correct type\n        meta_type: type[abc.Meta] = get_model_meta_type(model)\n        if not isinstance(meta, meta_type):\n            message: str = (\n                f\"Metadata assigned to `{get_qualified_name(type(model))}` \"\n                f\"must be of type `{get_qualified_name(meta_type)}`\"\n            )\n            raise ValueError(message)\n    if isinstance(model, abc.Model):\n        model._instance_meta = meta  # noqa: SLF001\n    else:\n        if not issubclass(model, abc.Model):\n            raise TypeError(model)\n        model._class_meta = meta  # noqa: SLF001\n</code></pre>"},{"location":"api/meta/#sob.meta.get_model_pointer","title":"get_model_pointer","text":"<pre><code>get_model_pointer(model: sob.abc.Model) -&gt; str | None\n</code></pre> <p>Get the JSON pointer associated with this model. Please note that this will typically only be available for models which have been deserialized from JSON data, otherwise, this function will return <code>None</code> (unless explicitly set using <code>set_model_pointer</code> on this instance, or a parent).</p> Source code in <code>src/sob/meta.py</code> <pre><code>def get_model_pointer(model: abc.Model) -&gt; str | None:\n    \"\"\"\n    Get the JSON pointer associated with this model. Please note that this\n    will typically only be available for models which have been deserialized\n    from JSON data, otherwise, this function will return `None` (unless\n    explicitly set using `set_model_pointer` on this instance, or a parent).\n    \"\"\"\n    return model._pointer  # noqa: SLF001\n</code></pre>"},{"location":"api/meta/#sob.meta.set_model_pointer","title":"set_model_pointer","text":"<pre><code>set_model_pointer(\n    model: sob.abc.Model, pointer_: str | None\n) -&gt; None\n</code></pre> <p>Set the JSON pointer associated with this model, and all models assigned to object properties, array items, or dictionary values of this model.</p> Source code in <code>src/sob/meta.py</code> <pre><code>def set_model_pointer(model: abc.Model, pointer_: str | None) -&gt; None:\n    \"\"\"\n    Set the JSON pointer associated with this model, and all models\n    assigned to object properties, array items, or dictionary values\n    of this model.\n    \"\"\"\n    key: str\n    value: Any\n    model._pointer = pointer_  # noqa: SLF001\n    if isinstance(model, abc.Dictionary):\n        for key, value in model.items():\n            if isinstance(\n                value,\n                (abc.Object, abc.Dictionary, abc.Array),\n            ):\n                set_model_pointer(\n                    value,\n                    \"{}/{}\".format(\n                        pointer_,\n                        (\n                            escape_reference_token(key)\n                            if isinstance(key, str)\n                            else str(key)\n                        ),\n                    ),\n                )\n    elif isinstance(model, abc.Object):\n        property_name: str\n        property_: abc.Property\n        for property_name, property_ in _read_object_properties(model) or ():\n            key = property_.name or property_name\n            value = getattr(model, property_name)\n            if isinstance(\n                value,\n                (abc.Object, abc.Dictionary, abc.Array),\n            ):\n                set_model_pointer(\n                    value,\n                    \"{}/{}\".format(\n                        pointer_,\n                        (\n                            escape_reference_token(key)\n                            if isinstance(key, str)\n                            else str(key)\n                        ),\n                    ),\n                )\n    elif isinstance(model, abc.Array):\n        index: int\n        for index in range(len(model)):\n            value = model[index]\n            if isinstance(\n                value,\n                (abc.Object, abc.Dictionary, abc.Array),\n            ):\n                set_model_pointer(value, f\"{pointer_}/{index!s}\")\n</code></pre>"},{"location":"api/meta/#sob.meta.pointer","title":"pointer","text":"<pre><code>pointer(\n    model: sob.abc.Model, pointer_: str | None = None\n) -&gt; str | None\n</code></pre> <p>Get or set a model's pointer</p> Source code in <code>src/sob/meta.py</code> <pre><code>@deprecated(\n    \"`sob.meta.pointer` is deprecated and will be removed in sob 3. \"\n    \"Use `sob.get_model_pointer` and `sob.set_model_pointer` \"\n    \"instead.\",\n)\ndef pointer(model: abc.Model, pointer_: str | None = None) -&gt; str | None:\n    \"\"\"\n    Get or set a model's pointer\n    \"\"\"\n    if not isinstance(model, (abc.Object, abc.Dictionary, abc.Array)):\n        raise TypeError(model)\n    if pointer_ is not None:\n        set_model_pointer(model, pointer_)\n    return get_model_pointer(model)\n</code></pre>"},{"location":"api/meta/#sob.meta.set_model_url","title":"set_model_url","text":"<pre><code>set_model_url(\n    model_instance: sob.abc.Model, source_url: str | None\n) -&gt; None\n</code></pre> <p>Set a source URL to be associated with this model, and all models assigned to object properties, array items, or dictionary values of this model.</p> Source code in <code>src/sob/meta.py</code> <pre><code>def set_model_url(model_instance: abc.Model, source_url: str | None) -&gt; None:\n    \"\"\"\n    Set a source URL to be associated with this model, and all models\n    assigned to object properties, array items, or dictionary values\n    of this model.\n    \"\"\"\n    if not isinstance(model_instance, (abc.Object, abc.Dictionary, abc.Array)):\n        raise TypeError(model_instance)\n    if (source_url is not None) and not isinstance(source_url, str):\n        raise TypeError(source_url)\n    model_instance._url = source_url  # noqa: SLF001\n    child_model: abc.Model\n    for child_model in _traverse_models(model_instance):\n        set_model_url(child_model, source_url)\n</code></pre>"},{"location":"api/meta/#sob.meta.get_model_url","title":"get_model_url","text":"<pre><code>get_model_url(model: sob.abc.Model) -&gt; str | None\n</code></pre> <p>Get the source URL from which this model was deserialized.</p> Source code in <code>src/sob/meta.py</code> <pre><code>def get_model_url(model: abc.Model) -&gt; str | None:\n    \"\"\"\n    Get the source URL from which this model was deserialized.\n    \"\"\"\n    return model._url  # noqa: SLF001\n</code></pre>"},{"location":"api/meta/#sob.meta.version_model","title":"version_model","text":"<pre><code>version_model(\n    data: sob.abc.Model,\n    specification: str,\n    version_number: (\n        str | int | collections.abc.Sequence[int]\n    ),\n) -&gt; None\n</code></pre> <p>Recursively alters model class or instance metadata based on version number metadata associated with an object's properties. This allows one data model to represent multiple versions of a specification and dynamically change based on the version of a specification represented.</p> <p>Parameters:</p> <ul> <li>data (sob.model.Model)</li> <li>specification (str): The specification to which the <code>version_number</code>   argument applies.</li> <li>version_number (str|int|[int]): A version number represented as text   (in the form of integers separated by periods), an integer, or a   sequence of integers.</li> </ul> Source code in <code>src/sob/meta.py</code> <pre><code>def version_model(\n    data: abc.Model,\n    specification: str,\n    version_number: str | int | Sequence[int],\n) -&gt; None:\n    \"\"\"\n    Recursively alters model class or instance metadata based on version number\n    metadata associated with an object's properties. This allows one data model\n    to represent multiple versions of a specification and dynamically change\n    based on the version of a specification represented.\n\n    Parameters:\n\n    - data ([sob.model.Model](#Model))\n    - specification (str): The specification to which the `version_number`\n      argument applies.\n    - version_number (str|int|[int]): A version number represented as text\n      (in the form of integers separated by periods), an integer, or a\n      sequence of integers.\n    \"\"\"\n    if not (\n        isinstance(version_number, (str, float))\n        or (\n            isinstance(version_number, Sequence)\n            and isinstance(next(iter(version_number)), int)\n        )\n    ):\n        raise TypeError(version_number)\n    if not isinstance(data, abc.Model):\n        raise TypeError(data)\n    if isinstance(data, abc.Object):\n        _version_object(data, specification, version_number)\n    elif isinstance(data, abc.Dictionary):\n        _version_dictionary(data, specification, version_number)\n    elif isinstance(data, abc.Array):\n        _version_array(data, specification, version_number)\n</code></pre>"},{"location":"api/model/","title":"sob.model","text":""},{"location":"api/model/#sob.model","title":"sob.model","text":"<p>This module defines the building blocks of an <code>sob</code> based data model.</p>"},{"location":"api/model/#sob.model.Model","title":"Model","text":"<pre><code>Model()\n</code></pre> <p>               Bases: <code>sob.abc.Model</code></p> <p>This class serves as a base class for <code>sob.Object</code>, <code>sob.Dictionary</code>, and <code>sob.Array</code>. This class should not be instantiated or sub-classed directly.</p> Source code in <code>src/sob/model.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._instance_meta: abc.Meta | None = None\n    self._instance_hooks: abc.Hooks | None = None\n    self._url: str | None = None\n    self._pointer: str | None = None\n</code></pre>"},{"location":"api/model/#sob.model.Array","title":"Array","text":"<pre><code>Array(\n    items: (\n        sob.abc.Array\n        | collections.abc.Iterable[\n            sob.abc.MarshallableTypes\n        ]\n        | str\n        | bytes\n        | sob.abc.Readable\n        | None\n    ) = None,\n    item_types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | sob.abc.Types\n        | type\n        | sob.abc.Property\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.model.Model</code>, <code>sob.abc.Array</code>, <code>sob.abc.Model</code></p> <p>This class may either be instantiated directly or serve as a base class for defining typed JSON arrays (python lists).</p> <p>Typing can be set at the instance level by providing the keyword argument <code>item_types</code> when initializing an instance of <code>sob.Array</code>, or by assigning item types to the class or instance metadata.</p> <p>Example:</p> <pre><code>from __future__ import annotations\nfrom io import StringIO\nfrom typing import IO, Iterable\nimport sob\nfrom datetime import datetime, date\n\nclass ObjectA(sob.Object):\n    __slots__: tuple[str, ...] = (\n        \"name\",\n        \"iso8601_datetime\",\n    )\n\n    def __init__(\n        self,\n        _data: str | IO | dict | None = None,\n        name: str | None = None,\n        iso8601_datetime: datetime | None = None,\n    ) -&gt; None:\n        self.name: str | None = name\n        self.iso8601_datetime: datetime | None = iso8601_datetime\n        super().__init__(_data)\n\n\nsob.get_writable_object_meta(ObjectA).properties = sob.Properties([\n    (\"name\", sob.StringProperty()),\n    (\n        \"iso8601_datetime\",\n        sob.DateTimeProperty(name=\"iso8601DateTime\")\n    ),\n])\n\nclass ObjectB(sob.Object):\n    __slots__: tuple[str, ...] = (\n        \"name\",\n        \"iso8601_date\",\n    )\n\n    def __init__(\n        self,\n        _data: str | IO | dict | None = None,\n        name: str | None = None,\n        iso8601_date: date | None = None,\n    ) -&gt; None:\n        self.name: str | None = name\n        self.iso8601_date: date | None = iso8601_date\n        super().__init__(_data)\n\n\nsob.get_writable_object_meta(ObjectB).properties = sob.Properties([\n    (\"name\", sob.StringProperty()),\n    (\"iso8601_date\", sob.DateProperty(name=\"iso8601Date\")),\n])\n\nclass ArrayA(sob.Array):\n    def __init__(\n        self,\n        items: (\n            Iterable[ObjectA|ObjectB|dict]\n            | IO\n            | str\n            | bytes\n            | None\n        ) = None,\n    ) -&gt; None:\n        super().__init__(items)\n\n\nsob.get_writable_array_meta(ArrayA).item_types = sob.Types([\n    ObjectA, ObjectB\n])\n\n\n# Instances can be initialized using attribute parameters\narray_a_instance_1: ArrayA = ArrayA(\n    [\n        ObjectA(\n            name=\"Object A\",\n            iso8601_datetime=datetime(1999, 12, 31, 23, 59, 59),\n        ),\n        ObjectB(\n            name=\"Object B\",\n            iso8601_date=date(1999, 12, 31),\n        ),\n    ]\n)\n\n# ...or by passing the JSON data, either as a string, bytes, sequence,\n# or file-like object, as the first positional argument when\n# initializing the class:\nassert array_a_instance_1 == ArrayA(\n    \"\"\"\n    [\n        {\n            \"name\": \"Object A\",\n            \"iso8601DateTime\": \"1999-12-31T23:59:59Z\"\n        },\n        {\n            \"name\": \"Object B\",\n            \"iso8601Date\": \"1999-12-31\"\n        }\n    ]\n    \"\"\"\n) == ArrayA(\n    [\n        {\n            \"name\": \"Object A\",\n            \"iso8601DateTime\": datetime(1999, 12, 31, 23, 59, 59)\n        },\n        {\n            \"name\": \"Object B\",\n            \"iso8601Date\": date(1999, 12, 31)\n        }\n    ]\n) == ArrayA(\n    StringIO(\n        \"\"\"\n        [\n            {\n                \"name\": \"Object A\",\n                \"iso8601DateTime\": \"1999-12-31T23:59:59Z\"\n            },\n            {\n                \"name\": \"Object B\",\n                \"iso8601Date\": \"1999-12-31\"\n            }\n        ]\n        \"\"\"\n    )\n)\n\n# An array instance can be serialized to JSON using the `sob.serialize`\n# function, or by simply casting it as a string\n\nassert sob.serialize(array_a_instance_1, indent=4) == \"\"\"\n[\n    {\n        \"name\": \"Object A\",\n        \"iso8601DateTime\": \"1999-12-31T23:59:59Z\"\n    },\n    {\n        \"name\": \"Object B\",\n        \"iso8601Date\": \"1999-12-31\"\n    }\n]\n\"\"\".strip()\n\nassert str(array_a_instance_1) == (\n    '[{\"name\": \"Object A\", \"iso8601DateTime\": \"1999-12-31T23:59:59Z\"}'\n    ', {\"name\": \"Object B\", \"iso8601Date\": \"1999-12-31\"}]'\n)\n\n# An array can be converted into a list of JSON-serializable\n# python objects using `sob.marshal`\nassert sob.marshal(array_a_instance_1) == [\n    {\n        \"name\": \"Object A\",\n        \"iso8601DateTime\": \"1999-12-31T23:59:59Z\"\n    },\n    {\n        \"name\": \"Object B\",\n        \"iso8601Date\": \"1999-12-31\"\n    }\n]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>items</code>               (<code>sob.abc.Array | collections.abc.Iterable[sob.abc.MarshallableTypes] | str | bytes | sob.abc.Readable | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>item_types</code>               (<code>collections.abc.Iterable[type | sob.abc.Property] | sob.abc.Types | type | sob.abc.Property | None</code>, default:                   <code>None</code> )           \u2013            </li> </ul> Source code in <code>src/sob/model.py</code> <pre><code>def __init__(\n    self,\n    items: (\n        abc.Array\n        | Iterable[abc.MarshallableTypes]\n        | str\n        | bytes\n        | abc.Readable\n        | None\n    ) = None,\n    item_types: (\n        Iterable[type | abc.Property]\n        | abc.Types\n        | type\n        | abc.Property\n        | None\n    ) = None,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        items:\n        item_types:\n    \"\"\"\n    Model.__init__(self)\n    self._instance_meta: abc.ArrayMeta | None = None\n    self._instance_hooks: abc.ArrayHooks | None = None\n    self._list: list[abc.MarshallableTypes] = []\n    self._init_url(items)\n    deserialized_items: (\n        Iterable[abc.MarshallableTypes] | abc.Model | None\n    ) = self._init_format(items)\n    if not isinstance(deserialized_items, (NoneType, Iterable)):\n        raise TypeError(deserialized_items)\n    self._init_item_types(deserialized_items, item_types)\n    self._init_items(deserialized_items)\n    self._init_pointer()\n</code></pre>"},{"location":"api/model/#sob.model.Dictionary","title":"Dictionary","text":"<pre><code>Dictionary(\n    items: (\n        sob.abc.Dictionary\n        | collections.abc.Mapping[\n            str, sob.abc.MarshallableTypes\n        ]\n        | collections.abc.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | str\n        | bytes\n        | None\n    ) = None,\n    value_types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | sob.abc.Types\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.model.Model</code>, <code>sob.abc.Dictionary</code>, <code>sob.abc.Model</code></p> <p>This class may either be instantiated directly or serve as a base class for defining JSON objects for which there is not a predetermined set of properties/attributes, but for which there may be a pre-determined set of permitted value types.</p> <p>Typing can be set at the instance level by providing the keyword argument <code>value_types</code> when initializing an instance of <code>sob.Dictionary</code>, or by assigning value types to the class or instance metadata.</p> <p>Example:</p> <pre><code>from __future__ import annotations\nimport sob\nfrom io import StringIO\nfrom typing import IO, Any, Iterable, Mapping\nfrom datetime import datetime, date\n\nclass ObjectA(sob.Object):\n    __slots__: tuple[str, ...] = (\n        \"name\",\n        \"iso8601_datetime\",\n    )\n\n    def __init__(\n        self,\n        _data: str | IO | dict | None = None,\n        name: str | None = None,\n        iso8601_datetime: datetime | None = None,\n    ) -&gt; None:\n        self.name: str | None = name\n        self.iso8601_datetime: datetime | None = iso8601_datetime\n        super().__init__(_data)\n\n\nsob.get_writable_object_meta(ObjectA).properties = sob.Properties([\n    (\"name\", sob.StringProperty()),\n    (\n        \"iso8601_datetime\",\n        sob.DateTimeProperty(name=\"iso8601DateTime\")\n    ),\n])\n\nclass ObjectB(sob.Object):\n    __slots__: tuple[str, ...] = (\n        \"name\",\n        \"iso8601_date\",\n    )\n\n    def __init__(\n        self,\n        _data: str | IO | dict | None = None,\n        name: str | None = None,\n        iso8601_date: date | None = None,\n    ) -&gt; None:\n        self.name: str | None = name\n        self.iso8601_date: date | None = iso8601_date\n        super().__init__(_data)\n\n\nsob.get_writable_object_meta(ObjectB).properties = sob.Properties([\n    (\"name\", sob.StringProperty()),\n    (\"iso8601_date\", sob.DateProperty(name=\"iso8601Date\")),\n])\n\nclass DictionaryA(sob.Dictionary):\n    def __init__(\n        self,\n        items: (\n            Mapping[str, Any]\n            | Iterable[tuple[str, ObjectA|ObjectB|dict]]\n            | IO\n            | str\n            | bytes\n            | None\n        ) = None,\n    ) -&gt; None:\n        super().__init__(items)\n\n\nsob.get_writable_dictionary_meta(DictionaryA).value_types = sob.Types([\n    ObjectA, ObjectB\n])\n\n\n# Instances can be initialized with a dictionary\ndictionary_a_instance_1: DictionaryA = DictionaryA(\n    {\n        \"a\": ObjectA(\n            name=\"Object A\",\n            iso8601_datetime=datetime(1999, 12, 31, 23, 59, 59),\n        ),\n        \"b\": ObjectB(\n            name=\"Object B\",\n            iso8601_date=date(1999, 12, 31),\n        ),\n    }\n)\n\n# ...or by passing the JSON data, either as a string, bytes, sequence,\n# or file-like object, as the first positional argument when\n# initializing the class:\nassert dictionary_a_instance_1 == DictionaryA(\n    \"\"\"\n    {\n        \"a\": {\n            \"name\": \"Object A\",\n            \"iso8601DateTime\": \"1999-12-31T23:59:59Z\"\n        },\n        \"b\": {\n            \"name\": \"Object B\",\n            \"iso8601Date\": \"1999-12-31\"\n        }\n    }\n    \"\"\"\n) == DictionaryA(\n    StringIO(\n        \"\"\"\n        {\n            \"a\": {\n                \"name\": \"Object A\",\n                \"iso8601DateTime\": \"1999-12-31T23:59:59Z\"\n            },\n            \"b\": {\n                \"name\": \"Object B\",\n                \"iso8601Date\": \"1999-12-31\"\n            }\n        }\n        \"\"\"\n    )\n) == DictionaryA(\n    (\n        (\n            \"a\",\n            ObjectA(\n                name=\"Object A\",\n                iso8601_datetime=datetime(1999, 12, 31, 23, 59, 59),\n            )\n        ),\n        (\n            \"b\",\n            ObjectB(\n                name=\"Object B\",\n                iso8601_date=date(1999, 12, 31),\n            )\n        ),\n    )\n)\n\n# A dictionary instance can be serialized to JSON using the\n# `sob.serialize` function, or by simply casting it as a string\nassert sob.serialize(dictionary_a_instance_1, indent=4) == \"\"\"\n{\n    \"a\": {\n        \"name\": \"Object A\",\n        \"iso8601DateTime\": \"1999-12-31T23:59:59Z\"\n    },\n    \"b\": {\n        \"name\": \"Object B\",\n        \"iso8601Date\": \"1999-12-31\"\n    }\n}\n\"\"\".strip()\n\nassert str(dictionary_a_instance_1) == (\n    '{\"a\": {\"name\": \"Object A\", \"iso8601DateTime\": '\n    '\"1999-12-31T23:59:59Z\"}, \"b\": {\"name\": \"Object B\", '\n    '\"iso8601Date\": \"1999-12-31\"}}'\n)\n\n# A dictionary can be converted into a JSON-serializable\n# objects using `sob.marshal`\nassert sob.marshal(dictionary_a_instance_1) == {\n    \"a\": {\n        \"name\": \"Object A\",\n        \"iso8601DateTime\": \"1999-12-31T23:59:59Z\"\n    },\n    \"b\": {\n        \"name\": \"Object B\",\n        \"iso8601Date\": \"1999-12-31\"\n    }\n}\n</code></pre> Source code in <code>src/sob/model.py</code> <pre><code>def __init__(\n    self,\n    items: (\n        abc.Dictionary\n        | Mapping[str, abc.MarshallableTypes]\n        | Iterable[tuple[str, abc.MarshallableTypes]]\n        | abc.Readable\n        | str\n        | bytes\n        | None\n    ) = None,\n    value_types: (\n        Iterable[type | abc.Property]\n        | type\n        | abc.Property\n        | abc.Types\n        | None\n    ) = None,\n) -&gt; None:\n    Model.__init__(self)\n    self._instance_hooks: abc.DictionaryHooks | None = None\n    self._instance_meta: abc.DictionaryMeta | None = None\n    self._dict: dict[str, abc.MarshallableTypes] = {}\n    self._init_url(items)\n    deserialized_items: (\n        Iterable[abc.MarshallableTypes]\n        | Mapping[str, abc.MarshallableTypes]\n        | abc.Model\n        | None\n    ) = self._init_format(items)\n    self._init_value_types(deserialized_items, value_types)  # type: ignore\n    self._init_items(deserialized_items)  # type: ignore\n    self._init_pointer()\n</code></pre>"},{"location":"api/model/#sob.model.Object","title":"Object","text":"<pre><code>Object(\n    _data: (\n        sob.abc.Object\n        | sob.abc.Dictionary\n        | collections.abc.Mapping[\n            str, sob.abc.MarshallableTypes\n        ]\n        | collections.abc.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | str\n        | bytes\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.model.Model</code>, <code>sob.abc.Object</code>, <code>sob.abc.Model</code></p> <p>This class serves as a base for defining models for JSON objects (python dictionaries) which have a predetermined set of properties (attributes). This class should not be instantiated directly, but rather sub-classed to create object models.</p> <p>Example:</p> <pre><code>from __future__ import annotations\nfrom io import StringIO\nfrom typing import IO, Iterable\nimport sob\nfrom datetime import datetime, date\n\nclass ObjectA(sob.Object):\n    __slots__: tuple[str, ...] = (\n        \"boolean\",\n        \"boolean_or_string\",\n        \"integer\",\n        \"number\",\n        \"object_a\",\n        \"iso8601_datetime\",\n        \"iso8601_date\",\n    )\n\n    def __init__(\n        self,\n        _data: str | IO | dict | Iterable | None = None,\n        boolean: bool | None = None,\n        boolean_or_string: bool | str | None = None,\n        integer: int | None = None,\n        enumerated: int | None = None,\n        number: float | None = None,\n        object_a: ObjectA | None = None,\n        iso8601_datetime: datetime | None = None,\n        iso8601_date: date | None = None,\n    ) -&gt; None:\n        self.boolean: bool | None = boolean\n        self.boolean_or_string: bool | str | None = boolean_or_string\n        self.integer: int | None = integer\n        self.enumerated: int | None = enumerated\n        self.number: float | None = integer\n        self.object_a: ObjectA | None = None\n        self.iso8601_datetime: datetime | None = iso8601_datetime\n        self.iso8601_date: date | None = iso8601_date\n        super().__init__(_data)\n\n\nsob.get_writable_object_meta(ObjectA).properties = sob.Properties([\n    (\"boolean\", sob.BooleanProperty()),\n    (\n        \"boolean_or_string\",\n        sob.Property(\n            name=\"booleanOrString\",\n            types=sob.Types([bool, str])\n        )\n    ),\n    (\"integer\", sob.IntegerProperty()),\n    (\"enumerated\", sob.EnumeratedProperty(values=(1, 2, 3))),\n    (\"number\", sob.NumberProperty()),\n    (\n        \"iso8601_datetime\",\n        sob.DateTimeProperty(name=\"iso8601DateTime\")\n    ),\n    (\"iso8601_date\", sob.DateProperty(name=\"iso8601Date\")),\n])\n\n# Instances can be initialized using attribute parameters\nobject_a_instance_1: ObjectA = ObjectA(\n    boolean=True,\n    boolean_or_string=\"Maybe\",\n    integer=99,\n    enumerated=2,\n    number=3.14,\n    iso8601_datetime=datetime(1999, 12, 31, 23, 59, 59),\n    iso8601_date=date(1999, 12, 31),\n)\n\n# ...or by passing the JSON data, either as a string, bytes, dict, or\n# file-like object, as the first positional argument when initializing\n# the class:\nassert object_a_instance_1 == ObjectA(\n    \"\"\"\n    {\n        \"boolean\": true,\n        \"booleanOrString\": \"Maybe\",\n        \"integer\": 99,\n        \"enumerated\": 2,\n        \"number\": 99,\n        \"iso8601DateTime\": \"1999-12-31T23:59:59Z\",\n        \"iso8601Date\": \"1999-12-31\"\n    }\n    \"\"\"\n) == ObjectA(\n    {\n        \"boolean\": True,\n        \"booleanOrString\": \"Maybe\",\n        \"integer\": 99,\n        \"enumerated\": 2,\n        \"number\": 99,\n        \"iso8601DateTime\": datetime(1999, 12, 31, 23, 59, 59),\n        \"iso8601Date\": date(1999, 12, 31)\n    }\n) == ObjectA(\n    (\n        (\"boolean\", True),\n        (\"booleanOrString\", \"Maybe\"),\n        (\"integer\", 99),\n        (\"enumerated\", 2),\n        (\"number\", 99),\n        (\"iso8601DateTime\", datetime(1999, 12, 31, 23, 59, 59)),\n        (\"iso8601Date\", date(1999, 12, 31))\n    )\n) == ObjectA(\n    StringIO(\n        \"\"\"\n        {\n            \"boolean\": true,\n            \"booleanOrString\": \"Maybe\",\n            \"integer\": 99,\n            \"enumerated\": 2,\n            \"number\": 99,\n            \"iso8601DateTime\": \"1999-12-31T23:59:59Z\",\n            \"iso8601Date\": \"1999-12-31\"\n        }\n        \"\"\"\n    )\n)\n\n# An object instance can be serialized to JSON using the\n# `sob.serialize` function, or by simply casting it as a string\n\nassert sob.serialize(object_a_instance_1, indent=4) == \"\"\"\n{\n    \"boolean\": true,\n    \"booleanOrString\": \"Maybe\",\n    \"integer\": 99,\n    \"enumerated\": 2,\n    \"number\": 99,\n    \"iso8601DateTime\": \"1999-12-31T23:59:59Z\",\n    \"iso8601Date\": \"1999-12-31\"\n}\n\"\"\".strip()\n\nassert str(object_a_instance_1) == (\n    '{\"boolean\": true, \"booleanOrString\": \"Maybe\", \"integer\": 99, '\n    '\"enumerated\": 2, \"number\": 99, '\n    '\"iso8601DateTime\": \"1999-12-31T23:59:59Z\", '\n    '\"iso8601Date\": \"1999-12-31\"}'\n)\n\n# An object can be converted into a dictionary of JSON-serializable\n# python objects using `sob.marshal`\nassert sob.marshal(object_a_instance_1) == {\n    \"boolean\": True,\n    \"booleanOrString\": \"Maybe\",\n    \"integer\": 99,\n    \"enumerated\": 2,\n    \"number\": 99,\n    \"iso8601DateTime\": \"1999-12-31T23:59:59Z\",\n    \"iso8601Date\": \"1999-12-31\"\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>_data</code>               (<code>sob.abc.Object | sob.abc.Dictionary | collections.abc.Mapping[str, sob.abc.MarshallableTypes] | collections.abc.Iterable[tuple[str, sob.abc.MarshallableTypes]] | sob.abc.Readable | str | bytes | None</code>, default:                   <code>None</code> )           \u2013            <p>JSON data with which to initialize this object. This may be a dictionary/mapping, a JSON string or bytes, a file-like object containing JSON data, or an iterable of key/value tuples.</p> </li> </ul> Source code in <code>src/sob/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        abc.Object\n        | abc.Dictionary\n        | Mapping[str, abc.MarshallableTypes]\n        | Iterable[tuple[str, abc.MarshallableTypes]]\n        | abc.Readable\n        | str\n        | bytes\n        | None\n    ) = None,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        _data: JSON data with which to initialize this object. This may\n            be a dictionary/mapping, a JSON string or bytes, a\n            file-like object containing JSON data, or an iterable of\n            key/value tuples.\n    \"\"\"\n    self._instance_meta: abc.ObjectMeta | None = None\n    self._instance_hooks: abc.ObjectHooks | None = None\n    self._extra: dict[str, abc.MarshallableTypes] | None = None\n    Model.__init__(self)\n    self._init_url(_data)\n    deserialized_data: (\n        Iterable[abc.MarshallableTypes]\n        | Mapping[str, abc.MarshallableTypes]\n        | abc.Model\n        | None\n    ) = self._init_format(_data)\n    if not (\n        isinstance(\n            deserialized_data, (abc.Object, abc.Dictionary, dict, Mapping)\n        )\n        or (deserialized_data is None)\n    ):\n        raise TypeError(deserialized_data)\n    self._data_init(deserialized_data)\n    self._init_pointer()\n</code></pre>"},{"location":"api/model/#sob.model.marshal","title":"marshal","text":"<pre><code>marshal(\n    data: sob.abc.MarshallableTypes,\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | sob.abc.Types\n        | None\n    ) = None,\n    value_types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | sob.abc.Types\n        | None\n    ) = None,\n    item_types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | sob.abc.Types\n        | None\n    ) = None,\n) -&gt; typing.Any\n</code></pre> <p>This function recursively converts data which is not serializable using <code>json.dumps</code> into data which can be represented as JSON.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>sob.abc.MarshallableTypes</code>)           \u2013            <p>The data to be marshalled, typically an instance of <code>sob.Model</code>.</p> </li> <li> <code>types</code>               (<code>collections.abc.Iterable[type | sob.abc.Property] | sob.abc.Types | None</code>, default:                   <code>None</code> )           \u2013            <p>Property definitions or type(s) associated with this data. This is typically only used for recursive calls, so not typically provided explicitly by client applications.</p> </li> <li> <code>value_types</code>               (<code>collections.abc.Iterable[type | sob.abc.Property] | sob.abc.Types | None</code>, default:                   <code>None</code> )           \u2013            <p>Property definitions or type(s) associated with this objects' dictionary values. This is typically only used for recursive calls, so not typically provided explicitly by client applications.</p> </li> <li> <code>item_types</code>               (<code>collections.abc.Iterable[type | sob.abc.Property] | sob.abc.Types | None</code>, default:                   <code>None</code> )           \u2013            <p>Property definitions or type(s) associated with this array's items. This is typically only used for recursive calls, so not typically provided explicitly by client applications.</p> </li> </ul> Source code in <code>src/sob/model.py</code> <pre><code>def marshal(  # noqa: C901\n    data: abc.MarshallableTypes,\n    types: Iterable[type | abc.Property] | abc.Types | None = None,\n    value_types: Iterable[type | abc.Property] | abc.Types | None = None,\n    item_types: Iterable[type | abc.Property] | abc.Types | None = None,\n) -&gt; Any:\n    \"\"\"\n    This function recursively converts data which is not serializable using\n    `json.dumps` into data which *can* be represented as JSON.\n\n    Parameters:\n        data: The data to be marshalled, typically an instance of `sob.Model`.\n        types: Property definitions or type(s) associated with this data.\n            This is typically only used for recursive calls, so not typically\n            provided explicitly by client applications.\n        value_types: Property definitions or type(s) associated with this\n            objects' dictionary values. This is typically only used for\n            recursive calls, so not typically provided explicitly by client\n            applications.\n        item_types: Property definitions or type(s) associated with this\n            array's items. This is typically only used for recursive calls,\n            so not typically provided explicitly by client applications.\n    \"\"\"\n    marshalled_data: abc.JSONTypes\n    if isinstance(data, Decimal):\n        # Instances of `decimal.Decimal` can'ts be serialized as JSON, so we\n        # convert them to `float`\n        marshalled_data = float(data)\n    elif (data is None) or isinstance(data, (str, int, float)):\n        # Don't do anything with `None`--this just means an attributes is not\n        # used for this instance (an explicit `null` would be passed as\n        # `sob.properties.types.NULL`).\n        marshalled_data = data\n    elif data is NULL:\n        marshalled_data = None\n    elif isinstance(data, abc.Model):\n        marshalled_data = data._marshal()  # noqa: SLF001\n    elif types is not None:\n        marshalled_data = _marshal_typed(data, types)\n    elif isinstance(data, datetime):\n        marshalled_data = datetime2str(data)\n    elif isinstance(data, date):\n        marshalled_data = date2str(data)\n    elif isinstance(data, (bytes, bytearray)):\n        # Convert `bytes` to base-64 encoded strings\n        marshalled_data = str(b64encode(data), \"ascii\")\n    elif isinstance(data, Collection):\n        marshalled_data = _marshal_collection(\n            data, value_types=value_types, item_types=item_types\n        )\n    elif isinstance(data, SupportsBytes):\n        # Convert objects which can be *cast* as `bytes` to\n        # base-64 encoded strings\n        marshalled_data = str(b64encode(bytes(data)), \"ascii\")\n    else:\n        message: str = f\"Cannot unmarshal: {data!r}\"\n        raise ValueError(message)\n    return marshalled_data\n</code></pre>"},{"location":"api/model/#sob.model.unmarshal","title":"unmarshal","text":"<pre><code>unmarshal(\n    data: sob.abc.MarshallableTypes,\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | sob.abc.Types\n    ) = (),\n    value_types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | sob.abc.Types\n    ) = (),\n    item_types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | sob.abc.Types\n    ) = (),\n) -&gt; typing.Any\n</code></pre> <p>Converts deserialized data into one of the provided types.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>sob.abc.MarshallableTypes</code>)           \u2013            </li> <li> <code>types</code>               (<code>collections.abc.Iterable[type | sob.abc.Property] | type | sob.abc.Property | sob.abc.Types</code>, default:                   <code>()</code> )           \u2013            <p>Property definitions or type(s) into which to attempt to un-marshal the data. If multiple types are provided, the first which does not raise an error or contain extraneous attributes is accepted. If the data has extraneous attributes for all types, the type with the fewest extraneous attributes is accepted.</p> </li> <li> <code>value_types</code>               (<code>collections.abc.Iterable[type | sob.abc.Property] | type | sob.abc.Property | sob.abc.Types</code>, default:                   <code>()</code> )           \u2013            <p>For dictionary-like objects, values will be un-marshalled as one of the provided property definitions or types.</p> </li> <li> <code>item_types</code>               (<code>collections.abc.Iterable[type | sob.abc.Property] | type | sob.abc.Property | sob.abc.Types</code>, default:                   <code>()</code> )           \u2013            <p>For sequences (lists/tuples), items will be un-marshalled as one of the provided property definitions or types.</p> </li> </ul> Source code in <code>src/sob/model.py</code> <pre><code>def unmarshal(\n    data: abc.MarshallableTypes,\n    types: (\n        Iterable[type | abc.Property] | type | abc.Property | abc.Types\n    ) = (),\n    value_types: (\n        Iterable[type | abc.Property] | type | abc.Property | abc.Types\n    ) = (),\n    item_types: (\n        Iterable[type | abc.Property] | type | abc.Property | abc.Types\n    ) = (),\n) -&gt; Any:\n    \"\"\"\n    Converts deserialized data into one of the provided types.\n\n    Parameters:\n        data:\n        types: Property definitions or type(s) into which to attempt to\n            un-marshal the data. If multiple types are provided,\n            the first which does not raise an error or contain extraneous\n            attributes is accepted. If the data has extraneous attributes\n            for all types, the type with the fewest extraneous attributes is\n            accepted.\n        value_types: For dictionary-like objects, values will be un-marshalled\n            as one of the provided property definitions or types.\n        item_types: For sequences (lists/tuples), items will be un-marshalled\n            as one of the provided property definitions or types.\n    \"\"\"\n    return _Unmarshal(\n        data, types=types, value_types=value_types, item_types=item_types\n    )()\n</code></pre>"},{"location":"api/model/#sob.model.serialize","title":"serialize","text":"<pre><code>serialize(\n    data: sob.abc.MarshallableTypes,\n    indent: int | None = None,\n) -&gt; str\n</code></pre> <p>This function serializes data, particularly instances of <code>sob.Model</code> sub-classes, into JSON encoded strings.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>sob.abc.MarshallableTypes</code>)           \u2013            </li> <li> <code>indent</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of spaces to use for indentation. If <code>None</code>, the JSON will be compacted (no line breaks or indentation).</p> </li> </ul> Source code in <code>src/sob/model.py</code> <pre><code>def serialize(\n    data: abc.MarshallableTypes,\n    indent: int | None = None,\n) -&gt; str:\n    \"\"\"\n    This function serializes data, particularly instances of `sob.Model`\n    sub-classes, into JSON encoded strings.\n\n    Parameters:\n        data:\n        indent: The number of spaces to use for indentation. If `None`,\n            the JSON will be compacted (no line breaks or indentation).\n    \"\"\"\n    string_data: str\n    if isinstance(data, abc.Model):\n        before_serialize: Callable[[abc.JSONTypes], abc.JSONTypes] | None\n        after_serialize: Callable[[str], str] | None\n        before_serialize, after_serialize = _get_serialize_instance_hooks(data)\n        marshalled_data: abc.JSONTypes = marshal(data)\n        if before_serialize is not None:\n            marshalled_data = before_serialize(marshalled_data)\n        string_data = json.dumps(marshalled_data, indent=indent)\n        if after_serialize is not None:\n            string_data = after_serialize(string_data)\n    else:\n        if not isinstance(data, abc.JSON_TYPES):\n            raise TypeError(data)\n        string_data = json.dumps(data, indent=indent)\n    return string_data\n</code></pre>"},{"location":"api/model/#sob.model.deserialize","title":"deserialize","text":"<pre><code>deserialize(\n    data: str | bytes | sob.abc.Readable | None,\n    coerce_unparseable: type[str | bytes] | None = None,\n) -&gt; typing.Any\n</code></pre> <p>This function deserializes JSON encoded data from a string, bytes, or a file-like object.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>str | bytes | sob.abc.Readable | None</code>)           \u2013            <p>This can be a string or file-like object containing JSON serialized data.</p> </li> <li> <code>coerce_unparseable</code>               (<code>type[str | bytes] | None</code>, default:                   <code>None</code> )           \u2013            <p>If <code>str</code> or <code>bytes</code> are provided, and the data provided cannot be parsed as JSON, it will be returned as the specified type. If <code>None</code> (the default), an error will be raised if the data cannot be parsed as JSON.</p> </li> </ul> <p>This function returns <code>None</code> (for JSON null values), or an instance of <code>str</code>, <code>dict</code>, <code>list</code>, <code>int</code>, <code>float</code> or <code>bool</code>.</p> Source code in <code>src/sob/model.py</code> <pre><code>def deserialize(\n    data: str | bytes | abc.Readable | None,\n    coerce_unparseable: type[str | bytes] | None = None,\n) -&gt; Any:\n    \"\"\"\n    This function deserializes JSON encoded data from a string, bytes,\n    or a file-like object.\n\n    Parameters:\n        data: This can be a string or file-like object\n            containing JSON serialized data.\n        coerce_unparseable: If `str` or `bytes` are provided, and\n            the data provided cannot be parsed as JSON, it will be returned\n            as the specified type. If `None` (the default), an error\n            will be raised if the data cannot be parsed as JSON.\n\n    This function returns `None` (for JSON null values), or an instance of\n    `str`, `dict`, `list`, `int`, `float` or `bool`.\n    \"\"\"\n    deserialized_data: abc.JSONTypes\n    if isinstance(data, str):\n        try:\n            deserialized_data = json.loads(\n                data,\n                strict=False,\n            )\n        except ValueError as error:\n            if coerce_unparseable:\n                return data\n            raise DeserializeError(\n                data=data,\n                message=get_exception_text(),\n            ) from error\n    elif isinstance(data, bytes):\n        str_data: str = str(data, encoding=\"utf-8\")\n        try:\n            deserialized_data = deserialize(str_data)\n        except DeserializeError as error:\n            if coerce_unparseable:\n                if issubclass(coerce_unparseable, bytes):\n                    return data\n                return str_data\n            raise DeserializeError(\n                data=data,\n                message=get_exception_text(),\n            ) from error\n    else:\n        if not isinstance(data, abc.Readable):\n            raise TypeError(data)\n        deserialized_data = deserialize(\n            read(data), coerce_unparseable=coerce_unparseable\n        )\n    return deserialized_data\n</code></pre>"},{"location":"api/model/#sob.model.validate","title":"validate","text":"<pre><code>validate(\n    data: typing.Any,\n    types: (\n        sob.abc.Types\n        | collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    *,\n    raise_errors: bool = True\n) -&gt; collections.abc.Sequence[str]\n</code></pre> <p>This function verifies that all properties/items/values of a model instance are of the correct data type(s), and that all required attributes are present (if applicable).</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>typing.Any</code>)           \u2013            </li> <li> <code>types</code>               (<code>sob.abc.Types | collections.abc.Iterable[type | sob.abc.Property] | None</code>, default:                   <code>None</code> )           \u2013            <p>Property definitions or types against which to attempt to validate the data.</p> </li> <li> <code>raise_errors</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, a validation error will be raised if the validation fails. If <code>False</code>, a list of error message strings will be returned.</p> </li> </ul> <p>If <code>raise_errors</code> is <code>True</code> (this is the default), violations will result in a validation error being raised. If <code>raise_errors</code> is <code>False</code>, a list of error messages will be returned.</p> Source code in <code>src/sob/model.py</code> <pre><code>def validate(\n    data: Any,\n    types: abc.Types | Iterable[type | abc.Property] | None = None,\n    *,\n    raise_errors: bool = True,\n) -&gt; Sequence[str]:\n    \"\"\"\n    This function verifies that all properties/items/values of a model instance\n    are of the correct data type(s), and that all required attributes are\n    present (if applicable).\n\n    Parameters:\n        data:\n        types: Property definitions or types against which to attempt to\n            validate the data.\n        raise_errors: If `True`, a validation error will be raised if\n            the validation fails. If `False`, a list of error message strings\n            will be returned.\n\n    If `raise_errors` is `True` (this is the default), violations will result\n    in a validation error being raised. If `raise_errors` is `False`, a list\n    of error messages will be returned.\n    \"\"\"\n    if isinstance(data, GeneratorType):\n        data = tuple(data)\n    error_messages: list[str] = []\n    if types is not None:\n        error_messages.extend(_validate_typed(data, types))\n    error_messages.extend(_call_validate_method(data))\n    if raise_errors and error_messages:\n        data_representation: str = f\"\\n\\n    {indent_(represent(data))}\"\n        error_messages_representation: str = \"\\n\\n\".join(error_messages)\n        if data_representation not in error_messages_representation:\n            error_messages_representation = (\n                f\"{data_representation}\\n\\n{error_messages_representation}\"\n            )\n        raise errors.ValidationError(error_messages_representation)\n    return error_messages\n</code></pre>"},{"location":"api/model/#sob.model.replace_model_nulls","title":"replace_model_nulls","text":"<pre><code>replace_model_nulls(\n    model_instance: sob.abc.Model,\n    replacement_value: sob.abc.MarshallableTypes = None,\n) -&gt; None\n</code></pre> <p>This function replaces all instances of <code>sob.properties.types.NULL</code>.</p> <p>Parameters:</p> <ul> <li>model_instance (sob.model.Model)</li> <li>replacement_value (typing.Any):   The value with which nulls will be replaced. This defaults to <code>None</code>.</li> </ul> Source code in <code>src/sob/model.py</code> <pre><code>def replace_model_nulls(\n    model_instance: abc.Model,\n    replacement_value: abc.MarshallableTypes = None,\n) -&gt; None:\n    \"\"\"\n    This function replaces all instances of `sob.properties.types.NULL`.\n\n    Parameters:\n\n    - model_instance (sob.model.Model)\n    - replacement_value (typing.Any):\n      The value with which nulls will be replaced. This defaults to `None`.\n    \"\"\"\n    if isinstance(model_instance, abc.Object):\n        _replace_object_nulls(model_instance, replacement_value)\n    elif isinstance(model_instance, abc.Array):\n        _replace_array_nulls(model_instance, replacement_value)\n    elif isinstance(model_instance, abc.Dictionary):\n        _replace_dictionary_nulls(model_instance, replacement_value)\n</code></pre>"},{"location":"api/model/#sob.model.get_model_from_meta","title":"get_model_from_meta","text":"<pre><code>get_model_from_meta(\n    name: str,\n    metadata: sob.abc.Meta,\n    module: str | None = None,\n    docstring: str | None = None,\n    pre_init_source: str = \"\",\n    post_init_source: str = \"\",\n) -&gt; type[sob.abc.Model]\n</code></pre> <p>Constructs an <code>sob.Object</code>, <code>sob.Array</code>, or <code>sob.Dictionary</code> sub-class from an instance of <code>sob.ObjectMeta</code>, <code>sob.ArrayMeta</code>, or <code>sob.DictionaryMeta</code>.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the class.</p> </li> <li> <code>class_meta</code>           \u2013            </li> <li> <code>module</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify the value for the class definition's <code>__module__</code> property. The invoking module will be used if this is not specified. Note: If using the result of this function with <code>sob.utilities.get_source</code> to generate static code--this should be set to \"main\". The default behavior is only appropriate when using this function as a factory.</p> </li> <li> <code>docstring</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A docstring to associate with the class definition.</p> </li> <li> <code>pre_init_source</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Source code to insert before the <code>__init__</code> function in the class definition.</p> </li> <li> <code>post_init_source</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Source code to insert after the <code>__init__</code> function in the class definition.</p> </li> </ul> Source code in <code>src/sob/model.py</code> <pre><code>def get_model_from_meta(\n    name: str,\n    metadata: abc.Meta,\n    module: str | None = None,\n    docstring: str | None = None,\n    pre_init_source: str = \"\",\n    post_init_source: str = \"\",\n) -&gt; type[abc.Model]:\n    \"\"\"\n    Constructs an `sob.Object`, `sob.Array`, or `sob.Dictionary` sub-class\n    from an instance of `sob.ObjectMeta`, `sob.ArrayMeta`, or\n    `sob.DictionaryMeta`.\n\n    Parameters:\n        name: The name of the class.\n        class_meta:\n        module: Specify the value for the class definition's\n            `__module__` property. The invoking module will be\n            used if this is not specified. Note: If using the result of this\n            function with `sob.utilities.get_source` to generate static\n            code--this should be set to \"__main__\". The default behavior is\n            only appropriate when using this function as a factory.\n        docstring: A docstring to associate with the class definition.\n        pre_init_source: Source code to insert *before* the `__init__`\n            function in the class definition.\n        post_init_source: Source code to insert *after* the `__init__`\n            function in the class definition.\n    \"\"\"\n    # For pickling to work, the __module__ variable needs to be set...\n    module = module or get_calling_module_name(2)\n    class_definition: str = _class_definition_from_meta(\n        name,\n        metadata,\n        docstring=docstring,\n        module=module,\n        pre_init_source=pre_init_source,\n        post_init_source=post_init_source,\n    )\n    namespace: dict[str, Any] = {\"__name__\": f\"from_meta_{name}\"}\n    imports = [\n        \"from __future__ import annotations\",\n        \"import typing\",\n    ]\n    # `decimal.Decimal` may or may not be referenced in a given model--so\n    # check first\n    if re.search(r\"\\bdecimal\\.Decimal\\b\", class_definition):\n        imports.append(\"import decimal\")\n    # `datetime` may or may not be referenced in a given model--so check\n    # first\n    if re.search(r\"\\bdatetime\\b\", class_definition):\n        imports.append(\"import datetime\")\n    imports.append(\"import sob\")\n    source: str = suffix_long_lines(\n        \"{}\\n\\n\\n{}\".format(\"\\n\".join(imports), class_definition)\n    )\n    error: Exception\n    try:\n        exec(source, namespace)  # noqa: S102\n    except Exception as error:\n        append_exception_text(error, f\"\\n\\n{source}\")\n        raise\n    model_class: type[abc.Model] = namespace[name]\n    model_class._source = source  # noqa: SLF001\n    model_class.__module__ = module\n    model_class._class_meta = metadata  # noqa: SLF001\n    return model_class\n</code></pre>"},{"location":"api/model/#sob.model.get_models_source","title":"get_models_source","text":"<pre><code>get_models_source(\n    *model_classes: type[sob.abc.Model],\n) -&gt; str\n</code></pre> <p>Get source code for a series of model classes, organized as a module. This is useful for generating a module from classes generated using <code>get_model_from_meta</code>.</p> Source code in <code>src/sob/model.py</code> <pre><code>def get_models_source(*model_classes: type[abc.Model]) -&gt; str:\n    \"\"\"\n    Get source code for a series of model classes, organized as a module.\n    This is useful for generating a module from classes generated\n    using `get_model_from_meta`.\n    \"\"\"\n    import_source_lines: list[str] = []\n    class_sources: list[str] = []\n    model_class: type[abc.Model]\n    class_names_metadata: dict[\n        str, abc.ObjectMeta | abc.ArrayMeta | abc.DictionaryMeta\n    ] = {}\n    for model_class in model_classes:\n        import_source: str\n        class_source: str\n        import_source, class_source = (\n            get_source(model_class).strip().rpartition(\"\\n\\n\\n\")[::2]\n        )\n        import_source_lines.extend(import_source.splitlines())\n        class_sources.append(class_source)\n        meta_instance: abc.Meta | None = meta.read_model_meta(model_class)\n        if not isinstance(\n            meta_instance,\n            (abc.ObjectMeta, abc.ArrayMeta, abc.DictionaryMeta),\n        ):\n            raise TypeError(meta_instance)\n        class_names_metadata[model_class.__name__] = meta_instance\n    class_name: str\n    metadata: abc.ObjectMeta | abc.ArrayMeta | abc.DictionaryMeta\n    metadata_sources: list[str] = []\n    for class_name, metadata in class_names_metadata.items():\n        if not isinstance(\n            metadata, (abc.ObjectMeta, abc.ArrayMeta, abc.DictionaryMeta)\n        ):\n            raise TypeError(metadata)\n        if isinstance(metadata, abc.ObjectMeta):\n            metadata_sources.append(\n                _get_class_meta_attribute_assignment_source(\n                    class_name, \"properties\", metadata\n                )\n            )\n        elif isinstance(metadata, abc.ArrayMeta):\n            metadata_sources.append(\n                _get_class_meta_attribute_assignment_source(\n                    class_name, \"item_types\", metadata\n                )\n            )\n        else:\n            metadata_sources.append(\n                _get_class_meta_attribute_assignment_source(\n                    class_name, \"value_types\", metadata\n                )\n            )\n    # De-duplicate imports while preserving order\n    imports_source = \"\\n\".join(dict.fromkeys(import_source_lines).keys())\n    classes_source: str = \"\\n\\n\\n\".join(class_sources)\n    metadata_source: str = \"\\n\".join(metadata_sources)\n    return f\"{imports_source}\\n\\n\\n{classes_source}\\n\\n\\n{metadata_source}\"\n</code></pre>"},{"location":"api/properties/","title":"sob.properties","text":""},{"location":"api/properties/#sob.properties","title":"sob.properties","text":"<p>This module defines classes for describing properties of a model.</p>"},{"location":"api/properties/#sob.properties.Property","title":"Property","text":"<pre><code>Property(\n    types: (\n        sob.abc.Types\n        | collections.abc.Sequence[\n            type | sob.properties.Property\n        ]\n        | type\n        | sob.properties.Property\n        | sob._types.Undefined\n        | None\n    ) = sob._types.UNDEFINED,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This is the base class for defining a property.</p> <p>Attributes:</p> <ul> <li> <code>types</code>               (<code>sob.abc.Types | None</code>)           \u2013            <p>One or more types or property definitions. More than one types and/or property definitions results in a polymorphic interpretation wherein a value is un-marshalled in accordance with each type or property in the list (sequentially), until the value is un-marshalled without throwing a <code>TypeError</code> or <code>ValueError</code>. If the list of types and/or properties is exhausted without successfully un-marshalling the value, a <code>TypeError</code> or <code>ValueError</code> error is raised. When types are sub-classes of <code>sob.Object</code>, each type is attempted, and of the resulting instances, the type resulting in the fewest extraneous attributes (attributes not corresponding to any metadata) is used.)</p> </li> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> </ul> Source code in <code>src/sob/properties.py</code> <pre><code>def __init__(\n    self,\n    types: abc.Types\n    | Sequence[type | Property]\n    | type\n    | Property\n    | Undefined\n    | None = UNDEFINED,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n) -&gt; None:\n    self._types: abc.Types | None = type(self)._types  # noqa: SLF001\n    if types is not UNDEFINED:\n        self.types = types  # type: ignore\n    self.name: str | None = name\n    self.required: bool = required\n    self._versions: Sequence[abc.Version] | None = None\n    if versions is not None:\n        self.versions = versions  # type: ignore\n</code></pre>"},{"location":"api/properties/#sob.properties.StringProperty","title":"StringProperty","text":"<pre><code>StringProperty(\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.StringProperty</code></p> <p>This class represents metadata describing a string property.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> </ul> Source code in <code>src/sob/properties.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n) -&gt; None:\n    super().__init__(\n        name=name,\n        required=required,\n        versions=versions,\n    )\n</code></pre>"},{"location":"api/properties/#sob.properties.DateProperty","title":"DateProperty","text":"<pre><code>DateProperty(\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None,\n    date2str: typing.Callable[\n        [datetime.date], str\n    ] = sob.properties.DateProperty._date2str,\n    str2date: typing.Callable[\n        [str], datetime.date\n    ] = sob.properties.DateProperty._str2date\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.DateProperty</code></p> <p>This class represents metadata describing a date property.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>required</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>versions</code>               (<code>str | sob.abc.Version | collections.abc.Iterable[str | sob.abc.Version] | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>date2str</code>               (<code>typing.Callable[[datetime.date], str]</code>, default:                   <code>sob.properties.DateProperty._date2str</code> )           \u2013            <p>A function, taking one argument (a python <code>date</code> json_object), and returning a date string in the desired format. The default is <code>datetime.date.isoformat</code> \u2014returning an ISO-8601 compliant date string.</p> </li> <li> <code>str2date</code>               (<code>typing.Callable[[str], datetime.date]</code>, default:                   <code>sob.properties.DateProperty._str2date</code> )           \u2013            <p>A function, taking one argument (a date string), and returning a python <code>date</code> object. By default, this is <code>iso8601.iso8601.parse_date</code>.</p> </li> </ul> Source code in <code>src/sob/properties.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n    date2str: Callable[[date], str] = _date2str,\n    str2date: Callable[[str], date] = _str2date,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        name:\n        required:\n        versions:\n        date2str: A function, taking one argument (a python `date`\n            json_object), and returning a date string in the\n            desired format. The default is `datetime.date.isoformat`\n            \u2014returning an ISO-8601 compliant date string.\n\n        str2date: A function, taking one argument (a date string), and\n            returning a python `date` object. By default, this is\n            `iso8601.iso8601.parse_date`.\n    \"\"\"\n    super().__init__(\n        name=name,\n        required=required,\n        versions=versions,\n    )\n    self._date2str = date2str\n    self._str2date = str2date\n</code></pre>"},{"location":"api/properties/#sob.properties.DateTimeProperty","title":"DateTimeProperty","text":"<pre><code>DateTimeProperty(\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None,\n    datetime2str: typing.Callable[\n        [datetime.datetime], str\n    ] = sob.properties.DateTimeProperty._datetime2str,\n    str2datetime: typing.Callable[\n        [str], datetime.datetime\n    ] = sob.properties.DateTimeProperty._str2datetime\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.DateTimeProperty</code></p> <p>This class represents metadata describing a date property.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>required</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>versions</code>               (<code>str | sob.abc.Version | collections.abc.Iterable[str | sob.abc.Version] | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>datetime2str</code>               (<code>typing.Callable[[datetime.datetime], str]</code>, default:                   <code>sob.properties.DateTimeProperty._datetime2str</code> )           \u2013            <p>A function, taking one argument (a python <code>datetime</code> json_object), and returning a date/time string in the desired format. The default is <code>datetime.datetime.isoformat</code>, returning an ISO-8601 compliant date/time string.</p> </li> <li> <code>str2datetime</code>               (<code>typing.Callable[[str], datetime.datetime]</code>, default:                   <code>sob.properties.DateTimeProperty._str2datetime</code> )           \u2013            <p>A function, taking one argument (a datetime string), and returning a python <code>datetime.datetime</code> object. By default, this is <code>iso8601.iso8601.parse_date</code>.</p> </li> </ul> Source code in <code>src/sob/properties.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n    datetime2str: Callable[[datetime], str] = _datetime2str,\n    str2datetime: Callable[[str], datetime] = _str2datetime,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        name:\n        required:\n        versions:\n        datetime2str: A function, taking one argument (a python `datetime`\n            json_object), and returning a date/time string in the desired\n            format. The default is `datetime.datetime.isoformat`,\n            returning an ISO-8601 compliant date/time string.\n        str2datetime: A function, taking one argument (a datetime string),\n            and returning a python `datetime.datetime` object. By default,\n            this is `iso8601.iso8601.parse_date`.\n    \"\"\"\n    self._datetime2str = datetime2str\n    self._str2datetime = str2datetime\n    super().__init__(\n        name=name,\n        required=required,\n        versions=versions,\n    )\n</code></pre>"},{"location":"api/properties/#sob.properties.BytesProperty","title":"BytesProperty","text":"<pre><code>BytesProperty(\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.BytesProperty</code></p> <p>This class represents metadata describing a property with binary values.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> </ul> Source code in <code>src/sob/properties.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n) -&gt; None:\n    super().__init__(\n        name=name,\n        required=required,\n        versions=versions,\n    )\n</code></pre>"},{"location":"api/properties/#sob.properties.EnumeratedProperty","title":"EnumeratedProperty","text":"<pre><code>EnumeratedProperty(\n    types: (\n        sob.abc.Types\n        | collections.abc.Sequence[\n            type | sob.properties.Property\n        ]\n        | type\n        | sob.properties.Property\n        | sob._types.Undefined\n        | None\n    ) = sob._types.UNDEFINED,\n    values: (\n        collections.abc.Iterable[sob.abc.MarshallableTypes]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.EnumeratedProperty</code></p> <p>This class represents metadata describing a property having a finite, pre-determined, set of possible values.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> <li> <code>values</code>               (<code>set[sob.abc.MarshallableTypes] | None</code>)           \u2013            <p>All possible values for this property.</p> </li> </ul> Source code in <code>src/sob/properties.py</code> <pre><code>def __init__(\n    self,\n    types: abc.Types\n    | Sequence[type | Property]\n    | type\n    | Property\n    | Undefined\n    | None = UNDEFINED,\n    values: Iterable[MarshallableTypes] | None = None,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n) -&gt; None:\n    self._values: set[MarshallableTypes] | None = None\n    super().__init__(\n        types=types, name=name, required=required, versions=versions\n    )\n    self.values = values  # type: ignore\n</code></pre>"},{"location":"api/properties/#sob.properties.NumberProperty","title":"NumberProperty","text":"<pre><code>NumberProperty(\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.NumberProperty</code></p> <p>This class represents metadata describing a property having numeric (decimal, float or integer) values.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> </ul> Source code in <code>src/sob/properties.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n) -&gt; None:\n    super().__init__(name=name, required=required, versions=versions)\n</code></pre>"},{"location":"api/properties/#sob.properties.IntegerProperty","title":"IntegerProperty","text":"<pre><code>IntegerProperty(\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.IntegerProperty</code></p> <p>This class represents metadata describing a property having integer values.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> </ul> Source code in <code>src/sob/properties.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n) -&gt; None:\n    super().__init__(\n        name=name,\n        required=required,\n        versions=versions,\n    )\n</code></pre>"},{"location":"api/properties/#sob.properties.BooleanProperty","title":"BooleanProperty","text":"<pre><code>BooleanProperty(\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.BooleanProperty</code></p> <p>This class represents metadata describing a property having boolean values.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> </ul> Source code in <code>src/sob/properties.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n) -&gt; None:\n    super().__init__(\n        name=name,\n        required=required,\n        versions=versions,\n    )\n</code></pre>"},{"location":"api/properties/#sob.properties.ArrayProperty","title":"ArrayProperty","text":"<pre><code>ArrayProperty(\n    item_types: (\n        type\n        | collections.abc.Sequence[\n            type | sob.properties.Property\n        ]\n        | sob._types.Undefined\n        | sob.abc.Types\n        | None\n    ) = sob._types.UNDEFINED,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.ArrayProperty</code></p> <p>This class represents metadata describing a property accepting array (list/tuple) values.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> <li> <code>item_types</code>               (<code>sob.abc.Types | None</code>)           \u2013            <p>The type(s) of values/objects contained in the array. Similar to <code>sob.Property().types</code>, but applied to items in the array, not the array itself.</p> </li> </ul> Source code in <code>src/sob/properties.py</code> <pre><code>def __init__(\n    self,\n    item_types: type\n    | Sequence[type | Property]\n    | Undefined\n    | abc.Types\n    | None = UNDEFINED,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n) -&gt; None:\n    self._item_types: Types | None = type(self)._item_types  # noqa: SLF001\n    if item_types is not UNDEFINED:\n        self.item_types = item_types  # type: ignore\n    super().__init__(\n        name=name,\n        required=required,\n        versions=versions,\n    )\n</code></pre>"},{"location":"api/properties/#sob.properties.DictionaryProperty","title":"DictionaryProperty","text":"<pre><code>DictionaryProperty(\n    value_types: (\n        type\n        | collections.abc.Sequence[\n            type | sob.properties.Property\n        ]\n        | sob._types.Undefined\n        | sob.abc.Types\n        | None\n    ) = sob._types.UNDEFINED,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.DictionaryProperty</code></p> <p>This class represents metadata describing a property accepting dictionary values (deserialized JSON objects without a pre-determined set of properties).</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> <li> <code>value_types</code>               (<code>sob.abc.Types | None</code>)           \u2013            <p>The type(s) of values/objects comprising the mapped values. Similar to <code>sob.Property().types</code>, but applied to values in the mapping/dictionary, not to the dictionary itself.</p> </li> </ul> Source code in <code>src/sob/properties.py</code> <pre><code>def __init__(\n    self,\n    value_types: type\n    | Sequence[type | Property]\n    | Undefined\n    | abc.Types\n    | None = UNDEFINED,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n) -&gt; None:\n    self._value_types: abc.Types | None = type(  # noqa: SLF001\n        self\n    )._value_types\n    if value_types is not UNDEFINED:\n        self.value_types = value_types  # type: ignore\n    super().__init__(\n        name=name,\n        required=required,\n        versions=versions,\n    )\n</code></pre>"},{"location":"api/properties/#sob.properties.has_mutable_types","title":"has_mutable_types","text":"<pre><code>has_mutable_types(\n    property_: sob.abc.Property | type[sob.abc.Property],\n) -&gt; bool\n</code></pre> <p>This function returns <code>True</code> if modification of the <code>.types</code> member of a property class or instance is permitted.</p> <p>Parameters:</p> <ul> <li> <code>property</code>           \u2013            </li> </ul> Source code in <code>src/sob/properties.py</code> <pre><code>def has_mutable_types(property_: abc.Property | type[abc.Property]) -&gt; bool:\n    \"\"\"\n    This function returns `True` if modification of the `.types` member of a\n    property class or instance is permitted.\n\n    Parameters:\n        property:\n    \"\"\"\n    property_type: type\n    if isinstance(property_, abc.Property):\n        property_type = type(property_)\n    else:\n        if not issubclass(property_, abc.Property):\n            raise TypeError(property_)\n        property_type = property_\n    return property_type._types is None  # noqa: SLF001\n</code></pre>"},{"location":"api/thesaurus/","title":"sob.thesaurus","text":""},{"location":"api/thesaurus/#sob.thesaurus","title":"sob.thesaurus","text":"<p>This module provides functionality for creating a data model from a set of example structures.</p>"},{"location":"api/thesaurus/#sob.thesaurus.Synonyms","title":"Synonyms","text":"<pre><code>Synonyms(\n    items: collections.abc.Iterable[\n        sob.abc.Readable | sob.abc.MarshallableTypes\n    ] = (),\n)\n</code></pre> <p>This class is a set-like object containing deserialized data, implied to represent variations of one type of entity, and is used to infer a model for that entity.</p> Source code in <code>src/sob/thesaurus.py</code> <pre><code>def __init__(\n    self, items: Iterable[abc.Readable | abc.MarshallableTypes] = ()\n) -&gt; None:\n    self._type: set[type] = set()\n    self._nullable: bool = False\n    self._set: set[abc.MarshallableTypes] = set()\n    if items:\n        self.__ior__(items)\n</code></pre>"},{"location":"api/thesaurus/#sob.thesaurus.Synonyms.add","title":"add","text":"<pre><code>add(\n    item: sob.abc.Readable | sob.abc.MarshallableTypes,\n) -&gt; None\n</code></pre> <p>This method adds a synonymous item to the set. If the item is a file-like (input/output) object, that object is first read, deserialized, and unmarshalled.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>sob.abc.Readable | sob.abc.MarshallableTypes</code>)           \u2013            <p>A file-like or a JSON-serializable python object.</p> </li> </ul> Source code in <code>src/sob/thesaurus.py</code> <pre><code>def add(  # noqa: C901\n    self, item: abc.Readable | abc.MarshallableTypes\n) -&gt; None:\n    \"\"\"\n    This method adds a synonymous item to the set. If the item is a\n    file-like (input/output) object, that object is first read,\n    deserialized, and unmarshalled.\n\n    Parameters:\n        item: A file-like or a JSON-serializable python object.\n    \"\"\"\n    if not isinstance(item, (abc.Readable, *abc.MARSHALLABLE_TYPES)):\n        raise TypeError(item)\n    if isinstance(item, abc.Readable):\n        # Deserialize and unmarshal file-like objects\n        item = unmarshal(deserialize(_read(item))[0])\n    elif isinstance(item, Iterable) and not isinstance(\n        item, (str, abc.Model, Mapping)\n    ):\n        if isinstance(item, Iterable) and not isinstance(item, Sequence):\n            item = tuple(item)\n        # Unmarshal items which appear to not have been part of an\n        # unmarshalled container\n        item = unmarshal(item)\n    if isinstance(item, Null):\n        self._nullable = True\n    elif item is not None:\n        if not isinstance(item, MARSHALLABLE_TYPES):\n            raise TypeError(item)\n        item_type: type = (\n            list\n            if isinstance(item, abc.Array)\n            else dict\n            if isinstance(item, abc.Dictionary)\n            else type(item)\n        )\n        if (item_type is int) and float in self._type:\n            pass\n        elif (item_type is float) and int in self._type:\n            self._type.remove(int)\n            self._type.add(item_type)\n        else:\n            self._type.add(item_type)\n        if not isinstance(item, Hashable):\n            if isinstance(item, Mapping):\n                item = Dictionary(item)\n            if isinstance(item, Sequence):\n                item = Array(item)\n        self._set.add(item)  # type: ignore\n</code></pre>"},{"location":"api/thesaurus/#sob.thesaurus.Synonyms.union","title":"union","text":"<pre><code>union(\n    other: collections.abc.Iterable[\n        sob.abc.Readable | sob.abc.MarshallableTypes\n    ],\n) -&gt; sob.thesaurus.Synonyms\n</code></pre> <p>This method returns an instance of <code>Synonyms</code> which incorporates all (non-redundant) items from both <code>self</code> and <code>other</code>.</p> Source code in <code>src/sob/thesaurus.py</code> <pre><code>def union(\n    self, other: Iterable[abc.Readable | abc.MarshallableTypes]\n) -&gt; Synonyms:\n    \"\"\"\n    This method returns an instance of `Synonyms` which incorporates\n    all (non-redundant) items from both `self` and `other`.\n    \"\"\"\n    new_synonyms: Synonyms = copy(self)\n    new_synonyms |= other\n    return new_synonyms\n</code></pre>"},{"location":"api/thesaurus/#sob.thesaurus.Synonyms.get_models","title":"get_models","text":"<pre><code>get_models(\n    pointer: str,\n    module: str = \"__main__\",\n    name: typing.Callable[\n        [str], str\n    ] = sob.thesaurus.get_class_name_from_pointer,\n) -&gt; collections.abc.Iterable[type]\n</code></pre> <p>Retrieve a sequence of class definitions representing a data model capable of describing these synonyms.</p> <p>Parameters:</p> <ul> <li>pointer (str): A JSON pointer for the top-level model class, used to   infer class names.</li> <li>module (str): The name of the module in which model classes will be   defined. This defaults to \"main\".</li> <li>name (str) = sob.thesaurus.get_class_name_from_pointer:   A function which accepts one <code>str</code> argument\u2014a synonym key   concatenated with \"#\" and JSON pointer (for example:   \"key#/body/items/0\") and which returns a <code>str</code> which will be the   resulting class name (for example: \"KeyBodyItemsItem\").</li> </ul> Source code in <code>src/sob/thesaurus.py</code> <pre><code>def get_models(\n    self,\n    pointer: str,\n    module: str = \"__main__\",\n    name: Callable[[str], str] = get_class_name_from_pointer,\n) -&gt; Iterable[type]:\n    \"\"\"\n    Retrieve a sequence of class definitions representing a data model\n    capable of describing these synonyms.\n\n    Parameters:\n\n    - pointer (str): A JSON pointer for the top-level model class, used to\n      infer class names.\n    - module (str): The name of the module in which model classes will be\n      defined. This defaults to \"__main__\".\n    - name (str) = sob.thesaurus.get_class_name_from_pointer:\n      A function which accepts one `str` argument\u2014a synonym key\n      concatenated with \"#\" and JSON pointer (for example:\n      \"key#/body/items/0\") and which returns a `str` which will be the\n      resulting class name (for example: \"KeyBodyItemsItem\").\n    \"\"\"\n    if not callable(name):\n        raise TypeError(name)\n    # This assertion ensures `self` contains data which can be described by\n    # a model class.\n    message: str\n    if not self._type:\n        message = \"No type could be identified\"\n        raise RuntimeError(message)\n    quoted_pointer: str = \"{}#\".format(quote_plus(pointer, safe=\"/+\"))\n    for model_class in self._iter_types(\n        pointer=quoted_pointer,\n        module=module,\n        name=name,\n    ):\n        if not issubclass(model_class, abc.Model):\n            raise TypeError((quoted_pointer, model_class))\n        yield model_class\n</code></pre>"},{"location":"api/thesaurus/#sob.thesaurus.Thesaurus","title":"Thesaurus","text":"<pre><code>Thesaurus(\n    _items: (\n        collections.abc.Mapping[\n            str,\n            collections.abc.Iterable[\n                sob.abc.Readable | sob.abc.MarshallableTypes\n            ]\n            | sob.thesaurus.Synonyms,\n        ]\n        | collections.abc.Iterable[\n            tuple[\n                str,\n                collections.abc.Iterable[\n                    sob.abc.Readable\n                    | sob.abc.MarshallableTypes\n                ]\n                | sob.thesaurus.Synonyms,\n            ]\n        ]\n        | sob.thesaurus.Thesaurus\n        | None\n    ) = None,\n    **kwargs: collections.abc.Iterable[\n        sob.abc.Readable | sob.abc.MarshallableTypes\n    ]\n)\n</code></pre> <p>An instance of <code>sob.Thesaurus</code> is a dictionary-like object wherein each value is an instance of <code>sob.Synonyms</code>.</p> <p>For example, if you have an API with several GET endpoints, the endpoint paths relative to the API base URL would make ideal keys for your <code>sob.Thesaurus</code> instance. After adding a representative sample of responses from each endpoint to the corresponding <code>sob.Synonyms</code> instance in your <code>sob.Thesaurus</code> instance, your thesaurus will be able to generate a python module with an <code>sob</code> based data model for all of your endpoints, including polymorphism where encountered.</p> <p>The keys of an <code>sob.Thesaurus</code> dictionary are meaningful in that they contribute to the naming of classes (which are formatted to comply with PEP-8, and to avoid collision with builtins, language keywords, etc.).</p> <p>For background: The <code>sob</code> library was designed for authoring a data model representing schemas defined by an OpenAPI specification. Although OpenAPI specifications are increasingly ubiquitous, there are scenarios where you might need to interact with an API which does not have an OpenAPI specification, or for which the OpenAPI specification is simply not available to you. In these cases, you can generate an <code>sob</code> model to validate your API responses using <code>sob.Thesaurus</code>.</p> <p>Parameters:</p> <ul> <li> <code>_items</code>               (<code>collections.abc.Mapping[str, collections.abc.Iterable[sob.abc.Readable | sob.abc.MarshallableTypes] | sob.thesaurus.Synonyms] | collections.abc.Iterable[tuple[str, collections.abc.Iterable[sob.abc.Readable | sob.abc.MarshallableTypes] | sob.thesaurus.Synonyms]] | sob.thesaurus.Thesaurus | None</code>, default:                   <code>None</code> )           \u2013            <p>A mapping of keys to values, where each value is an iterable of items which are synonymous with the key. This can either be an iterable of key/value pair tuples, or a dictionary-like object.</p> </li> </ul> Source code in <code>src/sob/thesaurus.py</code> <pre><code>def __init__(\n    self,\n    _items: Mapping[\n        str, Iterable[abc.Readable | abc.MarshallableTypes] | Synonyms\n    ]\n    | Iterable[\n        tuple[\n            str, Iterable[abc.Readable | abc.MarshallableTypes] | Synonyms\n        ]\n    ]\n    | Thesaurus\n    | None = None,\n    **kwargs: Iterable[abc.Readable | abc.MarshallableTypes],\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        _items: A mapping of keys to values, where each value is\n            an iterable of items which are synonymous with the key.\n            This can either be an iterable of key/value pair tuples,\n            or a dictionary-like object.\n    \"\"\"\n    self._dict: dict[str, Synonyms] = {}\n    key: str\n    value: Iterable[abc.Readable | abc.MarshallableTypes]\n    for key, value in dict(\n        *((_items,) if _items else ()), **kwargs\n    ).items():\n        self[key] = value\n</code></pre>"},{"location":"api/thesaurus/#sob.thesaurus.Thesaurus.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    key: str,\n    value: (\n        sob.thesaurus.Synonyms\n        | collections.abc.Iterable[\n            sob.abc.Readable | sob.abc.MarshallableTypes\n        ]\n    ),\n) -&gt; None\n</code></pre> <p>This method adds/overwrites the synonyms for the specified <code>key</code>. If the <code>value</code> is not an instance of <code>sob.Synonyms</code>, a new instance of <code>sob.Synonyms</code> is created and JSON data items from <code>value</code> are added to it.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>A string to utilize when attributing a unique name to the class representing these synonyms.</p> </li> <li> <code>value</code>               (<code>sob.thesaurus.Synonyms | collections.abc.Iterable[sob.abc.Readable | sob.abc.MarshallableTypes]</code>)           \u2013            <p>An iterable of JSON data which should be considered synonymous.</p> </li> </ul> Source code in <code>src/sob/thesaurus.py</code> <pre><code>def __setitem__(\n    self,\n    key: str,\n    value: Synonyms | Iterable[abc.Readable | abc.MarshallableTypes],\n) -&gt; None:\n    \"\"\"\n    This method adds/overwrites the synonyms for the specified `key`.\n    If the `value` is not an instance of `sob.Synonyms`, a new instance\n    of `sob.Synonyms` is created and JSON data items from `value` are\n    added to it.\n\n    Parameters:\n        key: A string to utilize when attributing a unique name to the\n            class representing these synonyms.\n        value: An iterable of JSON data which should be considered\n            synonymous.\n    \"\"\"\n    if not isinstance(value, Synonyms):\n        value = Synonyms(value)\n    return self._dict.__setitem__(key, value)\n</code></pre>"},{"location":"api/thesaurus/#sob.thesaurus.Thesaurus.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: str) -&gt; None\n</code></pre> <p>This method deletes the synonyms assigned the specified <code>key</code>.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            </li> </ul> Source code in <code>src/sob/thesaurus.py</code> <pre><code>def __delitem__(self, key: str) -&gt; None:\n    \"\"\"\n    This method deletes the synonyms assigned the specified `key`.\n\n    Parameters:\n        key:\n    \"\"\"\n    self._dict.__delitem__(key)\n</code></pre>"},{"location":"api/thesaurus/#sob.thesaurus.Thesaurus.pop","title":"pop","text":"<pre><code>pop(\n    key: str,\n    default: (\n        sob.thesaurus.Synonyms | sob._types.Undefined\n    ) = sob._types.UNDEFINED,\n) -&gt; sob.thesaurus.Synonyms\n</code></pre> <p>This method removes and returns the synonyms assigned to the specified <code>key</code>.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            </li> <li> <code>default</code>               (<code>sob.thesaurus.Synonyms | sob._types.Undefined</code>, default:                   <code>sob._types.UNDEFINED</code> )           \u2013            <p>A value to return if the specified <code>key</code> does not exist. If no default is provided, a <code>KeyError</code> will be raised if the key is not found.</p> </li> </ul> Source code in <code>src/sob/thesaurus.py</code> <pre><code>def pop(\n    self, key: str, default: Synonyms | Undefined = UNDEFINED\n) -&gt; Synonyms:\n    \"\"\"\n    This method removes and returns the synonyms assigned to the specified\n    `key`.\n\n    Parameters:\n        key:\n        default: A value to return if the specified `key` does not exist.\n            If no default is provided, a `KeyError` will be raised if the\n            key is not found.\n    \"\"\"\n    return self._dict.pop(\n        key,\n        **({} if isinstance(default, Undefined) else {\"default\": default}),\n    )\n</code></pre>"},{"location":"api/thesaurus/#sob.thesaurus.Thesaurus.popitem","title":"popitem","text":"<pre><code>popitem() -&gt; tuple[str, sob.thesaurus.Synonyms]\n</code></pre> <p>This method removes and returns a tuple of the most recently added key/synonyms pair (by default), or the first added key/synonyms pair if <code>last</code> is set to <code>False</code>.</p> Source code in <code>src/sob/thesaurus.py</code> <pre><code>def popitem(self) -&gt; tuple[str, Synonyms]:\n    \"\"\"\n    This method removes and returns a tuple of the most recently added\n    key/synonyms pair (by default), or the first added key/synonyms pair\n    if `last` is set to `False`.\n    \"\"\"\n    return self._dict.popitem()\n</code></pre>"},{"location":"api/thesaurus/#sob.thesaurus.Thesaurus.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>This method clears the thesaurus, removing all synonyms.</p> Source code in <code>src/sob/thesaurus.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    This method clears the thesaurus, removing all synonyms.\n    \"\"\"\n    self._dict.clear()\n</code></pre>"},{"location":"api/thesaurus/#sob.thesaurus.Thesaurus.update","title":"update","text":"<pre><code>update(\n    **kwargs: (\n        sob.thesaurus.Synonyms\n        | collections.abc.Iterable[\n            sob.abc.Readable | sob.abc.MarshallableTypes\n        ]\n    ),\n) -&gt; None\n</code></pre> <p>This method updates the thesaurus with one or more specified synonyms.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>               (<code>sob.thesaurus.Synonyms | collections.abc.Iterable[sob.abc.Readable | sob.abc.MarshallableTypes]</code>, default:                   <code>{}</code> )           \u2013            <p>A mapping of keys to values, where each value is an iterable of items which are synonymous with the key, or is an instance of <code>sob.Synonyms</code>.</p> </li> </ul> Source code in <code>src/sob/thesaurus.py</code> <pre><code>def update(\n    self,\n    **kwargs: Synonyms | Iterable[abc.Readable | abc.MarshallableTypes],\n) -&gt; None:\n    \"\"\"\n    This method updates the thesaurus with one or more specified synonyms.\n\n    Parameters:\n        kwargs: A mapping of keys to values, where each value is\n            an iterable of items which are synonymous with the key,\n            or is an instance of `sob.Synonyms`.\n    \"\"\"\n    key: str\n    value: Iterable[abc.Readable | abc.MarshallableTypes]\n    for key, value in kwargs.items():\n        self[key] = value\n</code></pre>"},{"location":"api/thesaurus/#sob.thesaurus.Thesaurus.setdefault","title":"setdefault","text":"<pre><code>setdefault(\n    key: str,\n    default: collections.abc.Iterable[\n        sob.abc.Readable | sob.abc.MarshallableTypes\n    ],\n) -&gt; sob.thesaurus.Synonyms\n</code></pre> <p>This method assigns <code>default</code> synonyms to the specified <code>key</code> if no synonyms have previously been assigned to the key, and returns either the existing or newly assigned synonyms.</p> Source code in <code>src/sob/thesaurus.py</code> <pre><code>def setdefault(\n    self,\n    key: str,\n    default: Iterable[abc.Readable | abc.MarshallableTypes],\n) -&gt; Synonyms:\n    \"\"\"\n    This method assigns `default` synonyms to the specified `key` if\n    no synonyms have previously been assigned to the key, and returns\n    either the existing or newly assigned synonyms.\n    \"\"\"\n    if not isinstance(default, Synonyms):\n        default = Synonyms(default)\n    return self._dict.setdefault(key, default)\n</code></pre>"},{"location":"api/thesaurus/#sob.thesaurus.Thesaurus.get_module_source","title":"get_module_source","text":"<pre><code>get_module_source(\n    name: typing.Callable[\n        [str], str\n    ] = sob.thesaurus.get_class_name_from_pointer,\n) -&gt; str\n</code></pre> <p>This method generates and returns the source code for a module defining data models applicable to the data contained in this thesaurus.</p> <p>Parameters:</p> <ul> <li>name (str) = sob.thesaurus.get_class_name_from_pointer:   A function which accepts one <code>str</code> argument\u2014a synonym key   concatenated with \"#\" and JSON pointer (for example:   \"key#/body/items/0\") and which returns a <code>str</code> which will be the   resulting class name (for example: \"KeyBodyItemsItem\").</li> </ul> Source code in <code>src/sob/thesaurus.py</code> <pre><code>def get_module_source(\n    self, name: Callable[[str], str] = get_class_name_from_pointer\n) -&gt; str:\n    \"\"\"\n    This method generates and returns the source code for a module\n    defining data models applicable to the data contained in this\n    thesaurus.\n\n    Parameters:\n\n    - name (str) = sob.thesaurus.get_class_name_from_pointer:\n      A function which accepts one `str` argument\u2014a synonym key\n      concatenated with \"#\" and JSON pointer (for example:\n      \"key#/body/items/0\") and which returns a `str` which will be the\n      resulting class name (for example: \"KeyBodyItemsItem\").\n    \"\"\"\n    return get_models_source(\n        *self.get_models(module=\"__main__\", name=name)\n    )\n</code></pre>"},{"location":"api/thesaurus/#sob.thesaurus.Thesaurus.get_module","title":"get_module","text":"<pre><code>get_module(\n    name: typing.Callable[\n        [str], str\n    ] = sob.thesaurus.get_class_name_from_pointer,\n) -&gt; types.ModuleType\n</code></pre> <p>This method generates and returns a module defining data models applicable to the data contained in this thesaurus. This module is not suitable for writing out for static use--use <code>Thesaurus.save_module</code> to generate and write a model suitable for static use.</p> <p>Parameters:</p> <ul> <li>name (str) = sob.thesaurus.get_class_name_from_pointer:   A function which accepts one <code>str</code> argument\u2014a synonym key   concatenated with \"#\" and JSON pointer (for example:   \"key#/body/items/0\") and which returns a <code>str</code> which will be the   resulting class name (for example: \"KeyBodyItemsItem\").</li> </ul> Source code in <code>src/sob/thesaurus.py</code> <pre><code>def get_module(\n    self, name: Callable[[str], str] = get_class_name_from_pointer\n) -&gt; ModuleType:\n    \"\"\"\n    This method generates and returns a module defining data models\n    applicable to the data contained in this thesaurus. This module is not\n    suitable for writing out for static use--use `Thesaurus.save_module`\n    to generate and write a model suitable for static use.\n\n    Parameters:\n\n    - name (str) = sob.thesaurus.get_class_name_from_pointer:\n      A function which accepts one `str` argument\u2014a synonym key\n      concatenated with \"#\" and JSON pointer (for example:\n      \"key#/body/items/0\") and which returns a `str` which will be the\n      resulting class name (for example: \"KeyBodyItemsItem\").\n    \"\"\"\n    # For pickling to work, the `__module__` variable needs to be set to\n    # the calling module.\n    module_name: str = get_calling_module_name(2)\n    module: ModuleType = ModuleType(module_name)\n    exec(  # noqa: S102\n        self._get_module_source(module_name, name=name), module.__dict__\n    )\n    return module\n</code></pre>"},{"location":"api/thesaurus/#sob.thesaurus.Thesaurus.save_module","title":"save_module","text":"<pre><code>save_module(\n    path: str | pathlib.Path,\n    name: typing.Callable[\n        [str], str\n    ] = sob.thesaurus.get_class_name_from_pointer,\n) -&gt; None\n</code></pre> <p>This method generates and saves the source code for a module defining data models applicable to the data contained in this thesaurus.</p> <p>Parameters:</p> <ul> <li>path (str): The file path where the data will be written.</li> <li>name (str) = sob.thesaurus.get_class_name_from_pointer:   A function which accepts one <code>str</code> argument\u2014a synonym key   concatenated with \"#\" and JSON pointer (for example:   \"key#/body/items/0\") and which returns a <code>str</code> which will be the   resulting class name (for example: \"KeyBodyItemsItem\").</li> </ul> Source code in <code>src/sob/thesaurus.py</code> <pre><code>def save_module(\n    self,\n    path: str | Path,\n    name: Callable[[str], str] = get_class_name_from_pointer,\n) -&gt; None:\n    \"\"\"\n    This method generates and saves the source code for a module\n    defining data models applicable to the data contained in this\n    thesaurus.\n\n    Parameters:\n\n    - path (str): The file path where the data will be written.\n    - name (str) = sob.thesaurus.get_class_name_from_pointer:\n      A function which accepts one `str` argument\u2014a synonym key\n      concatenated with \"#\" and JSON pointer (for example:\n      \"key#/body/items/0\") and which returns a `str` which will be the\n      resulting class name (for example: \"KeyBodyItemsItem\").\n    \"\"\"\n    if isinstance(path, str):\n        path = Path(path)\n    os.makedirs(path.parent, exist_ok=True)\n    module_source: str = self.get_module_source(name=name)\n    with open(path, \"w\") as module_io:\n        module_io.write(f\"{module_source}\\n\")\n</code></pre>"},{"location":"api/thesaurus/#sob.thesaurus.get_class_name_from_pointer","title":"get_class_name_from_pointer","text":"<pre><code>get_class_name_from_pointer(pointer: str) -&gt; str\n</code></pre> <p>This function creates a class name based on the <code>sob.Thesaurus</code> key of the <code>sob.Synonyms</code> instance to which an element belongs, combined with the JSON pointer of the applicable element. This function can be substituted for another, when generating a module from a thesaurus, by passing a function to the <code>name</code> parameter of <code>sob.Thesaurus.get_module_source</code>, <code>sob.Thesaurus.get_module</code>, or <code>sob.Thesaurus.save_module</code>.</p> <p>Parameters:</p> <ul> <li>pointer (str): The synonyms key + JSON pointer of the element for which   the class is being generated.</li> </ul> Source code in <code>src/sob/thesaurus.py</code> <pre><code>def get_class_name_from_pointer(pointer: str) -&gt; str:\n    \"\"\"\n    This function creates a class name based on the `sob.Thesaurus` key of the\n    `sob.Synonyms` instance to which an element belongs,\n    combined with the *JSON pointer* of the applicable element. This function\n    can be substituted for another, when generating a module from a thesaurus,\n    by passing a function to the `name` parameter of\n    `sob.Thesaurus.get_module_source`, `sob.Thesaurus.get_module`, or\n    `sob.Thesaurus.save_module`.\n\n    Parameters:\n\n    - pointer (str): The synonyms key + JSON pointer of the element for which\n      the class is being generated.\n    \"\"\"\n    return get_class_name(\n        f\"{pointer[:-2]}/item\"\n        if pointer.endswith(\"/0\")\n        else pointer.replace(\"/0/\", \"/item/\")\n    )\n</code></pre>"},{"location":"api/thesaurus/#sob.thesaurus.get_class_meta_attribute_assignment_source","title":"get_class_meta_attribute_assignment_source","text":"<pre><code>get_class_meta_attribute_assignment_source(\n    class_name_: str,\n    attribute_name: str,\n    metadata: sob.abc.Meta,\n) -&gt; str\n</code></pre> <p>This function generates source code for setting a metadata attribute on a class.</p> <p>Parameters:</p> <ul> <li>class_name (str): The name of the class to which we want to assign a   metadata attribute.</li> <li>attribute_name (str): The name of the attribute we want to assign.</li> <li>metadata (sob.abc.Meta): The metadata from which to take the assigned   value.</li> </ul> Source code in <code>src/sob/thesaurus.py</code> <pre><code>def get_class_meta_attribute_assignment_source(\n    class_name_: str,\n    attribute_name: str,\n    metadata: abc.Meta,\n) -&gt; str:\n    \"\"\"\n    This function generates source code for setting a metadata attribute on\n    a class.\n\n    Parameters:\n\n    - class_name (str): The name of the class to which we want to assign a\n      metadata attribute.\n    - attribute_name (str): The name of the attribute we want to assign.\n    - metadata (sob.abc.Meta): The metadata from which to take the assigned\n      value.\n    \"\"\"\n    writable_function_name: str = \"sob.get_writable_{}_meta\".format(\n        \"object\"\n        if isinstance(metadata, abc.ObjectMeta)\n        else (\"array\" if isinstance(metadata, abc.ArrayMeta) else \"dictionary\")\n    )\n    # We insert \"  # type: ignore\" at the end of the first line where the value\n    # is assigned due to mypy issues with properties having getters and setters\n    return suffix_long_lines(\n        (\n            f\"{writable_function_name}(  # type: ignore\\n\"\n            f\"    {suffix_long_lines(class_name_, -4)}\\n\"\n            f\").{attribute_name} = {getattr(metadata, attribute_name)!r}\"\n        ),\n        -4,\n    )\n</code></pre>"},{"location":"api/types/","title":"sob.types","text":""},{"location":"api/types/#sob.types","title":"sob.types","text":""},{"location":"api/types/#sob.types.NULL","title":"NULL  <code>module-attribute</code>","text":"<pre><code>NULL: sob._types.Null = sob._types.Null()\n</code></pre> <p><code>sob.NULL</code> is the singleton instance of <code>sob.Null</code>, and is used to represent an explicit <code>null</code> value in JSON, whereas in the context of an instance of a sub-class of <code>sob.Object</code>\u2014<code>None</code> indicates the absence of a property value.</p>"},{"location":"api/types/#sob.types.UNDEFINED","title":"UNDEFINED  <code>module-attribute</code>","text":"<pre><code>UNDEFINED: sob._types.Undefined = sob._types.Undefined()\n</code></pre> <p><code>sob.UNDEFINED</code> is the singleton instance of <code>sob.Undefined</code>, and is used to indicate that a parameter has not been passed to a function or method keyword.</p>"},{"location":"api/types/#sob.types.Null","title":"Null","text":"<pre><code>Null()\n</code></pre> <p>Instances of this class represent an explicit null value, rather than the absence of a property/attribute/element, as would be inferred from a value of <code>None</code>.</p> <p>Note: Like the built-in value <code>None</code>, only one instance of this class is permitted (it's a singleton), so this class should never be instantiated, it should always be referenced through the constant <code>sob.NULL</code>.</p> Source code in <code>src/sob/_types.py</code> <pre><code>def __init__(self) -&gt; None:\n    if \"NULL\" in _module_locals:\n        message: str = f\"{self!r} may only be defined once.\"\n        raise DefinitionExistsError(message)\n</code></pre>"},{"location":"api/types/#sob.types.Undefined","title":"Undefined","text":"<pre><code>Undefined()\n</code></pre> <p>This class is intended to indicate that a parameter has not been passed to a keyword argument in situations where <code>None</code> is to be used as a meaningful value.</p> <p>The <code>Undefined</code> class is a singleton, so only one instance of this class is permitted: <code>sob.UNDEFINED</code>.</p> Source code in <code>src/sob/_types.py</code> <pre><code>def __init__(self) -&gt; None:\n    # Only one instance of `Undefined` is permitted, so initialization\n    # checks to make sure this is the first use.\n    if \"UNDEFINED\" in _module_locals:\n        message: str = f\"{self!r} may only be instantiated once.\"\n        raise DefinitionExistsError(message)\n</code></pre>"},{"location":"api/types/#sob.types.Types","title":"Types","text":"<pre><code>Types(\n    items: (\n        sob.abc.Types\n        | collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Types</code></p> <p>Instances of this class are immutable lists of types and/or property definitions.</p> Source code in <code>src/sob/types.py</code> <pre><code>def __init__(\n    self,\n    items: abc.Types\n    | Iterable[type | abc.Property]\n    | type\n    | abc.Property\n    | None = None,\n) -&gt; None:\n    if isinstance(items, (type, abc.Property)):\n        items = (items,)\n    self._list: list[type | abc.Property] = []\n    if items is not None:\n        self._extend(items)\n</code></pre>"},{"location":"api/types/#sob.types.MutableTypes","title":"MutableTypes","text":"<pre><code>MutableTypes(\n    items: (\n        sob.abc.Types\n        | collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.types.Types</code>, <code>sob.abc.MutableTypes</code></p> <p>Instances of this class are (mutable) lists of types and/or property definitions.</p> Source code in <code>src/sob/types.py</code> <pre><code>def __init__(\n    self,\n    items: abc.Types\n    | Iterable[type | abc.Property]\n    | type\n    | abc.Property\n    | None = None,\n) -&gt; None:\n    if isinstance(items, (type, abc.Property)):\n        items = (items,)\n    self._list: list[type | abc.Property] = []\n    if items is not None:\n        self._extend(items)\n</code></pre>"},{"location":"api/utilities/","title":"sob.utilities","text":""},{"location":"api/utilities/#sob.utilities","title":"sob.utilities","text":""},{"location":"api/utilities/#sob.utilities.get_property_name","title":"get_property_name","text":"<pre><code>get_property_name(name: str) -&gt; str\n</code></pre> <p>Converts a \"camelCased\" attribute/property name, a name which conflicts with a python keyword, or an otherwise non-compatible string to a PEP-8 compliant property name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; print(get_property_name(\"theBirdsAndTheBees\"))\nthe_birds_and_the_bees\n\n&gt;&gt;&gt; print(get_property_name(\"theBirdsAndTheBEEs\"))\nthe_birds_and_the_bees\n\n&gt;&gt;&gt; print(get_property_name(\"theBirdsAndTheBEEsEs\"))\nthe_birds_and_the_be_es_es\n\n&gt;&gt;&gt; print(get_property_name(\"FYIThisIsAnAcronym\"))\nfyi_this_is_an_acronym\n\n&gt;&gt;&gt; print(get_property_name(\"in\"))\nin_\n\n&gt;&gt;&gt; print(get_property_name(\"id\"))\nid_\n\n&gt;&gt;&gt; print(get_property_name(\"one2one\"))  # No change needed\none2one\n\n&gt;&gt;&gt; print(get_property_name(\"One2One\"))\none_2_one\n\n&gt;&gt;&gt; print(get_property_name(\"@One2One\"))\none_2_one\n\n&gt;&gt;&gt; print(get_property_name(\"One2One-ALL\"))\none_2_one_all\n\n&gt;&gt;&gt; print(get_property_name(\"one2one-ALL\"))\none2one_all\n\n&gt;&gt;&gt; print(get_property_name(\"type\"))\ntype_\n\n&gt;&gt;&gt; print(get_property_name(\"@type\"))\ntype_\n</code></pre> Source code in <code>src/sob/utilities.py</code> <pre><code>def get_property_name(name: str) -&gt; str:\n    \"\"\"\n    Converts a \"camelCased\" attribute/property name, a name which conflicts\n    with a python keyword, or an otherwise non-compatible string to a PEP-8\n    compliant property name.\n\n    Examples:\n\n        &gt;&gt;&gt; print(get_property_name(\"theBirdsAndTheBees\"))\n        the_birds_and_the_bees\n\n        &gt;&gt;&gt; print(get_property_name(\"theBirdsAndTheBEEs\"))\n        the_birds_and_the_bees\n\n        &gt;&gt;&gt; print(get_property_name(\"theBirdsAndTheBEEsEs\"))\n        the_birds_and_the_be_es_es\n\n        &gt;&gt;&gt; print(get_property_name(\"FYIThisIsAnAcronym\"))\n        fyi_this_is_an_acronym\n\n        &gt;&gt;&gt; print(get_property_name(\"in\"))\n        in_\n\n        &gt;&gt;&gt; print(get_property_name(\"id\"))\n        id_\n\n        &gt;&gt;&gt; print(get_property_name(\"one2one\"))  # No change needed\n        one2one\n\n        &gt;&gt;&gt; print(get_property_name(\"One2One\"))\n        one_2_one\n\n        &gt;&gt;&gt; print(get_property_name(\"@One2One\"))\n        one_2_one\n\n        &gt;&gt;&gt; print(get_property_name(\"One2One-ALL\"))\n        one_2_one_all\n\n        &gt;&gt;&gt; print(get_property_name(\"one2one-ALL\"))\n        one2one_all\n\n        &gt;&gt;&gt; print(get_property_name(\"type\"))\n        type_\n\n        &gt;&gt;&gt; print(get_property_name(\"@type\"))\n        type_\n    \"\"\"\n    # Replace accented and otherwise modified latin characters with their\n    # basic latin equivalent\n    name = normalize(\"NFKD\", name)\n    # Replace any remaining non-latin characters with underscores\n    name = re.sub(r\"([^\\x20-\\x7F]|\\s)+\", \"_\", name)\n    # Only insert underscores between letters and numbers if camelCasing is\n    # found in the original string\n    if re.search(r\"[A-Z][a-z]\", name) or re.search(r\"[a-z][A-Z]\", name):\n        name = re.sub(r\"([0-9])([a-zA-Z])\", r\"\\1_\\2\", name)\n        name = re.sub(r\"([a-zA-Z])([0-9])\", r\"\\1_\\2\", name)\n    # Insert underscores between lowercase and uppercase characters\n    name = re.sub(r\"([a-z])([A-Z])\", r\"\\1_\\2\", name)\n    # Insert underscores between uppercase characters and following uppercase\n    # characters which are followed by lowercase characters (indicating the\n    # latter uppercase character was intended as part of a capitalized word),\n    # except where the trailing lowercase character is a solo lowercase \"s\"\n    # (pluralizing the acronym).\n    name = re.sub(r\"([A-Z])([A-Z])([a-rt-z]|s(?!\\b))\", r\"\\1_\\2\\3\", name)\n    # Replace any series of one or more non-alphanumeric characters remaining\n    # with a single underscore\n    name = re.sub(r\"[^\\w_]+\", \"_\", name).lower()\n    # Replace any two or more adjacent underscores with a single underscore\n    name = re.sub(r\"__+\", \"_\", name).lstrip(\"_\")\n    # Append an underscore to the keyword until it does not conflict with any\n    # python keywords, built-ins, or potential module imports\n    while (\n        iskeyword(name)\n        or (name in builtins.__dict__)\n        or (name in {\"self\", \"decimal\", \"datetime\", \"typing\", \"type\"})\n    ):\n        name = f\"{name}_\"\n    return name\n</code></pre>"},{"location":"api/utilities/#sob.utilities.get_class_name","title":"get_class_name","text":"<pre><code>get_class_name(name: str) -&gt; str\n</code></pre> <p>This function accepts a string and returns a variation of that string which is a PEP-8 compatible python class name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; print(get_class_name(\"the birds and the bees\"))\nTheBirdsAndTheBees\n\n&gt;&gt;&gt; print(get_class_name(\"the-birds-and-the-bees\"))\nTheBirdsAndTheBees\n\n&gt;&gt;&gt; print(get_class_name(\"**the - birds - and - the - bees**\"))\nTheBirdsAndTheBees\n\n&gt;&gt;&gt; print(get_class_name(\"FYI is an acronym\"))\nFYIIsAnAcronym\n\n&gt;&gt;&gt; print(get_class_name(\"in-you-go\"))\nInYouGo\n\n&gt;&gt;&gt; print(get_class_name(\"False\"))\nFalse_\n\n&gt;&gt;&gt; print(get_class_name(\"True\"))\nTrue_\n\n&gt;&gt;&gt; print(get_class_name(\"ABC Acronym\"))\nABCAcronym\n\n&gt;&gt;&gt; print(get_class_name(\"AB CD Efg\"))\nABCdEfg\n</code></pre> Source code in <code>src/sob/utilities.py</code> <pre><code>def get_class_name(name: str) -&gt; str:\n    \"\"\"\n    This function accepts a string and returns a variation of that string\n    which is a PEP-8 compatible python class name.\n\n    Examples:\n\n        &gt;&gt;&gt; print(get_class_name(\"the birds and the bees\"))\n        TheBirdsAndTheBees\n\n        &gt;&gt;&gt; print(get_class_name(\"the-birds-and-the-bees\"))\n        TheBirdsAndTheBees\n\n        &gt;&gt;&gt; print(get_class_name(\"**the - birds - and - the - bees**\"))\n        TheBirdsAndTheBees\n\n        &gt;&gt;&gt; print(get_class_name(\"FYI is an acronym\"))\n        FYIIsAnAcronym\n\n        &gt;&gt;&gt; print(get_class_name(\"in-you-go\"))\n        InYouGo\n\n        &gt;&gt;&gt; print(get_class_name(\"False\"))\n        False_\n\n        &gt;&gt;&gt; print(get_class_name(\"True\"))\n        True_\n\n        &gt;&gt;&gt; print(get_class_name(\"ABC Acronym\"))\n        ABCAcronym\n\n        &gt;&gt;&gt; print(get_class_name(\"AB CD Efg\"))\n        ABCdEfg\n    \"\"\"\n    name = camel(name, capitalize=True)\n    while iskeyword(name) or (name in builtins.__dict__):\n        name = f\"{name}_\"\n    if name.startswith(_DIGITS_TUPLE):\n        name = f\"_{name}\"\n    return name\n</code></pre>"},{"location":"api/utilities/#sob.utilities.camel","title":"camel","text":"<pre><code>camel(string: str, *, capitalize: bool = False) -&gt; str\n</code></pre> <p>This function returns a camelCased representation of the input string.</p> <p>Parameters:</p> <ul> <li> <code>string</code>               (<code>str</code>)           \u2013            <p>The string to be camelCased.</p> </li> <li> <code>capitalize</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If this is <code>true</code>, the first letter will be capitalized.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; print(camel(\"the birds and the bees\"))\ntheBirdsAndTheBees\n\n&gt;&gt;&gt; print(camel(\"the birds and the bees\", capitalize=True))\nTheBirdsAndTheBees\n\n&gt;&gt;&gt; print(camel(\"the-birds-and-the-bees\"))\ntheBirdsAndTheBees\n\n&gt;&gt;&gt; print(camel(\"**the - birds - and - the - bees**\"))\ntheBirdsAndTheBees\n\n&gt;&gt;&gt; print(camel(\"FYI is an acronym\"))\nFYIIsAnAcronym\n\n&gt;&gt;&gt; print(camel(\"in-you-go\"))\ninYouGo\n\n&gt;&gt;&gt; print(camel(\"False\"))\nfalse\n\n&gt;&gt;&gt; print(camel(\"True\"))\ntrue\n\n&gt;&gt;&gt; print(camel(\"in\"))\nin\n\n&gt;&gt;&gt; print(camel(\"AB CD Efg\", capitalize=True))\nABCdEfg\n\n&gt;&gt;&gt; print(camel(\"ABC DEF GHI\", capitalize=True))\nAbcDefGhi\n\n&gt;&gt;&gt; print(camel(\"ABC_DEF_GHI\", capitalize=True))\nAbcDefGhi\n\n&gt;&gt;&gt; print(camel(\"ABC DEF GHI\"))\nabcDefGhi\n\n&gt;&gt;&gt; print(camel(\"ABC_DEF_GHI\"))\nabcDefGhi\n\n&gt;&gt;&gt; print(camel(\"AB_CDEfg\"))\nABCdEfg\n</code></pre> Source code in <code>src/sob/utilities.py</code> <pre><code>def camel(string: str, *, capitalize: bool = False) -&gt; str:\n    \"\"\"\n    This function returns a camelCased representation of the input string.\n\n    Parameters:\n        string: The string to be camelCased.\n        capitalize: If this is `true`, the first letter will be capitalized.\n\n    Examples:\n\n        &gt;&gt;&gt; print(camel(\"the birds and the bees\"))\n        theBirdsAndTheBees\n\n        &gt;&gt;&gt; print(camel(\"the birds and the bees\", capitalize=True))\n        TheBirdsAndTheBees\n\n        &gt;&gt;&gt; print(camel(\"the-birds-and-the-bees\"))\n        theBirdsAndTheBees\n\n        &gt;&gt;&gt; print(camel(\"**the - birds - and - the - bees**\"))\n        theBirdsAndTheBees\n\n        &gt;&gt;&gt; print(camel(\"FYI is an acronym\"))\n        FYIIsAnAcronym\n\n        &gt;&gt;&gt; print(camel(\"in-you-go\"))\n        inYouGo\n\n        &gt;&gt;&gt; print(camel(\"False\"))\n        false\n\n        &gt;&gt;&gt; print(camel(\"True\"))\n        true\n\n        &gt;&gt;&gt; print(camel(\"in\"))\n        in\n\n        &gt;&gt;&gt; print(camel(\"AB CD Efg\", capitalize=True))\n        ABCdEfg\n\n        &gt;&gt;&gt; print(camel(\"ABC DEF GHI\", capitalize=True))\n        AbcDefGhi\n\n        &gt;&gt;&gt; print(camel(\"ABC_DEF_GHI\", capitalize=True))\n        AbcDefGhi\n\n        &gt;&gt;&gt; print(camel(\"ABC DEF GHI\"))\n        abcDefGhi\n\n        &gt;&gt;&gt; print(camel(\"ABC_DEF_GHI\"))\n        abcDefGhi\n\n        &gt;&gt;&gt; print(camel(\"AB_CDEfg\"))\n        ABCdEfg\n    \"\"\"\n    index: int\n    character: str\n    string = normalize(\"NFKD\", string)\n    characters: list[str] = []\n    all_uppercase: bool = string.upper() == string\n    capitalize_next: bool = capitalize\n    uncapitalize_next: bool = (not capitalize) and (\n        len(string) &lt; 2  # noqa: PLR2004\n        or all_uppercase\n        or not (\n            string[0] in _UPPERCASE_ALPHABET\n            and string[1] in _UPPERCASE_ALPHABET\n        )\n    )\n    for index, character in enumerate(string):\n        if character in _ALPHANUMERIC_CHARACTERS:\n            if capitalize_next:\n                if all_uppercase:\n                    uncapitalize_next = True\n                elif capitalize or characters:\n                    # This prevents two acronyms which are adjacent from\n                    # retaining capitalization (since word separations would\n                    # not be possible to identify if caps were kept for both)\n                    if characters and (characters[-1] in _UPPERCASE_ALPHABET):\n                        uncapitalize_next = True\n                    character = character.upper()  # noqa: PLW2901\n            elif uncapitalize_next and character:\n                if character in _LOWERCASE_ALPHABET:\n                    uncapitalize_next = False\n                else:\n                    character = character.lower()  # noqa: PLW2901\n                    # Halt lowercasing if the next character starts a\n                    # camelCased word\n                    next_index: int = index + 1\n                    tail: str = string[next_index:]\n                    if (\n                        len(tail) &gt; 1\n                        and tail[0] in _UPPERCASE_ALPHABET\n                        and tail[1] in _LOWERCASE_ALPHABET\n                    ):\n                        uncapitalize_next = False\n            characters.append(character)\n            capitalize_next = False\n        else:\n            capitalize_next = True\n            uncapitalize_next = False\n    return \"\".join(characters)\n</code></pre>"},{"location":"api/utilities/#sob.utilities.camel_split","title":"camel_split","text":"<pre><code>camel_split(string: str) -&gt; tuple[str, ...]\n</code></pre> <p>Split a string of camelCased words into a tuple.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; camel_split(\"theBirdsAndTheBees\")\n('the', 'Birds', 'And', 'The', 'Bees')\n\n&gt;&gt;&gt; camel_split(\"theBirdsAndTheBees123\")\n('the', 'Birds', 'And', 'The', 'Bees', '123')\n\n&gt;&gt;&gt; camel_split(\"theBirdsAndTheBeesABC123\")\n('the', 'Birds', 'And', 'The', 'Bees', 'ABC', '123')\n\n&gt;&gt;&gt; camel_split(\"the-Birds-&amp;-The-Bs-ABC--123\")\n('the', '-', 'Birds', '-&amp;-', 'The', '-', 'Bs', '-', 'ABC', '--', '123')\n\n&gt;&gt;&gt; camel_split(\"THEBirdsAndTheBees\")\n('THE', 'Birds', 'And', 'The', 'Bees')\n</code></pre> Source code in <code>src/sob/utilities.py</code> <pre><code>def camel_split(string: str) -&gt; tuple[str, ...]:\n    \"\"\"\n    Split a string of camelCased words into a tuple.\n\n    Examples:\n\n        &gt;&gt;&gt; camel_split(\"theBirdsAndTheBees\")\n        ('the', 'Birds', 'And', 'The', 'Bees')\n\n        &gt;&gt;&gt; camel_split(\"theBirdsAndTheBees123\")\n        ('the', 'Birds', 'And', 'The', 'Bees', '123')\n\n        &gt;&gt;&gt; camel_split(\"theBirdsAndTheBeesABC123\")\n        ('the', 'Birds', 'And', 'The', 'Bees', 'ABC', '123')\n\n        &gt;&gt;&gt; camel_split(\"the-Birds-&amp;-The-Bs-ABC--123\")\n        ('the', '-', 'Birds', '-&amp;-', 'The', '-', 'Bs', '-', 'ABC', '--', '123')\n\n        &gt;&gt;&gt; camel_split(\"THEBirdsAndTheBees\")\n        ('THE', 'Birds', 'And', 'The', 'Bees')\n    \"\"\"\n    words: list[list[str]] = []\n    preceding_character_type: _CharacterType | None = None\n    for character in string:\n        character_type: _CharacterType = (\n            _CharacterType.LOWERCASE\n            if character in _LOWERCASE_ALPHABET\n            else (\n                _CharacterType.DIGIT\n                if character in _DIGITS\n                else (\n                    _CharacterType.UPPERCASE\n                    if character in _UPPERCASE_ALPHABET\n                    else _CharacterType.OTHER\n                )\n            )\n        )\n        if character_type == _CharacterType.LOWERCASE:\n            if preceding_character_type == _CharacterType.LOWERCASE:\n                # If following another lowercase character, a lowercase\n                # character always continues that word\n                words[-1].append(character)\n            elif preceding_character_type == _CharacterType.UPPERCASE:\n                if len(words[-1]) &gt; 1:\n                    # When following a multi-character uppercase word,\n                    # the preceding word's last character should be removed\n                    # and a new word created from that preceding character\n                    # as well as the current lowercase character (until\n                    # followed by a lowercase character, the preceding\n                    # uppercase character was inferred to be part of an,\n                    # however now we know it was either following an acronym,\n                    # or following a single-character word)\n                    words.append([words[-1].pop(), character])\n                else:\n                    # When following an uppercase character, a lowercase\n                    # character should be added to the preceding word if that\n                    # word has only one character thus far\n                    words[-1].append(character)\n            else:\n                words.append([character])\n            preceding_character_type = _CharacterType.LOWERCASE\n        else:\n            # Any type of character besides one from the *lowercase alphabet*\n            # should start a new word if it follows a character of a\n            # different type\n            if preceding_character_type == character_type:\n                words[-1].append(character)\n            else:\n                words.append([character])\n            preceding_character_type = character_type\n    return tuple(\"\".join(word) for word in words)\n</code></pre>"},{"location":"api/utilities/#sob.utilities.indent","title":"indent","text":"<pre><code>indent(\n    string: str,\n    number_of_spaces: int = 4,\n    start: int = 1,\n    stop: int | None = None,\n) -&gt; str\n</code></pre> <p>Indent text by <code>number_of_spaces</code> starting at line index <code>start</code> and stopping at line index <code>stop</code>.</p> Source code in <code>src/sob/utilities.py</code> <pre><code>def indent(\n    string: str,\n    number_of_spaces: int = 4,\n    start: int = 1,\n    stop: int | None = None,\n) -&gt; str:\n    \"\"\"\n    Indent text by `number_of_spaces` starting at line index `start` and\n    stopping at line index `stop`.\n    \"\"\"\n    indented_text = string\n    if (\"\\n\" in string) or start == 0:\n        lines: list[str] = string.split(\"\\n\")\n        if stop:\n            if stop &lt; 0:\n                stop = len(lines) - stop\n        else:\n            stop = len(lines)\n        index: int\n        for index in range(start, stop):\n            line: str = lines[index]\n            line_indent: str = \" \" * number_of_spaces\n            lines[index] = f\"{line_indent}{line}\".rstrip()\n        indented_text = \"\\n\".join(lines)\n    return indented_text\n</code></pre>"},{"location":"api/utilities/#sob.utilities.get_url_relative_to","title":"get_url_relative_to","text":"<pre><code>get_url_relative_to(\n    absolute_url: str, base_url: str\n) -&gt; str\n</code></pre> <p>Returns a relative URL given an absolute URL and a base URL</p> Source code in <code>src/sob/utilities.py</code> <pre><code>def get_url_relative_to(absolute_url: str, base_url: str) -&gt; str:\n    \"\"\"\n    Returns a relative URL given an absolute URL and a base URL\n    \"\"\"\n    # If no portion of the absolute URL is shared with the base URL--the\n    # absolute URL will be returned\n    relative_url: str = absolute_url\n    base_url = _url_directory_and_file_name(base_url)[0]\n    if base_url:\n        relative_url = \"\"\n        # URLs are not case-sensitive\n        base_url = base_url.lower()\n        lowercase_absolute_url = absolute_url.lower()\n        while base_url and (\n            base_url.lower() != lowercase_absolute_url[: len(base_url)]\n        ):\n            relative_url = \"../\" + relative_url\n            base_url = _url_directory_and_file_name(base_url[:-1])[0]\n        base_url_length: int = len(base_url)\n        relative_url += absolute_url[base_url_length:]\n    return relative_url\n</code></pre>"},{"location":"api/utilities/#sob.utilities.split_long_docstring_lines","title":"split_long_docstring_lines","text":"<pre><code>split_long_docstring_lines(\n    docstring: str,\n    max_line_length: int = sob.utilities.MAX_LINE_LENGTH,\n    indent: int = 4,\n) -&gt; str\n</code></pre> <p>Split long docstring lines.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; print(\n...     split_long_docstring_lines(\n...         \"    Lorem ipsum dolor sit amet, consectetur adipiscing \"\n...         \"elit. Nullam faucibu odio a urna elementum, eu tempor \"\n...         \"nisl efficitur.\"\n...     )\n... )\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam faucibu\n    odio a urna elementum, eu tempor nisl efficitur.\n</code></pre> Source code in <code>src/sob/utilities.py</code> <pre><code>def split_long_docstring_lines(\n    docstring: str,\n    max_line_length: int = MAX_LINE_LENGTH,\n    indent: int = 4,\n) -&gt; str:\n    \"\"\"\n    Split long docstring lines.\n\n    Example:\n\n        &gt;&gt;&gt; print(\n        ...     split_long_docstring_lines(\n        ...         \"    Lorem ipsum dolor sit amet, consectetur adipiscing \"\n        ...         \"elit. Nullam faucibu odio a urna elementum, eu tempor \"\n        ...         \"nisl efficitur.\"\n        ...     )\n        ... )\n            Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam faucibu\n            odio a urna elementum, eu tempor nisl efficitur.\n    \"\"\"  # noqa: E501\n    line: str\n    indent_: str = \"    \"\n    if \"\\t\" in docstring:\n        docstring = docstring.replace(\"\\t\", indent_)\n    lines: list[str] = docstring.split(\"\\n\")\n    indentation_length: int = sys.maxsize\n    for line in filter(None, lines):\n        matched = re.match(r\"^[ ]+\", line)\n        if matched:\n            indentation_length = min(indentation_length, len(matched.group()))\n        else:\n            indentation_length = 0\n            break\n    indent_ = \" \" * (indentation_length or indent)\n    if indentation_length &lt; sys.maxsize:\n        docstring = \"\\n\".join(\n            _split_long_comment_line(\n                indent_ + line[indentation_length:],\n                max_line_length,\n                prefix=\"\",\n            )\n            for line in lines\n        )\n    # Strip trailing whitespace and empty lines\n    return re.sub(r\"[ ]+(\\n|$)\", r\"\\1\", docstring)\n</code></pre>"},{"location":"api/utilities/#sob.utilities.suffix_long_lines","title":"suffix_long_lines","text":"<pre><code>suffix_long_lines(\n    text: str,\n    max_line_length: int = sob.utilities.MAX_LINE_LENGTH,\n    suffix: str = \"  # noqa: E501\",\n) -&gt; str\n</code></pre> <p>This function adds a suffix to the end of any line of code longer than <code>max_line_length</code>.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>Text representing python code</p> </li> <li> <code>max_line_length</code>               (<code>int</code>, default:                   <code>sob.utilities.MAX_LINE_LENGTH</code> )           \u2013            <p>The length at which a line should have the <code>suffix</code> appended. If this is a negative integer (or zero), the sum of this integer + <code>MAX_LINE_LENGTH</code> is used</p> </li> <li> <code>suffix</code>               (<code>str</code>, default:                   <code>'  # noqa: E501'</code> )           \u2013            <p>The default suffix indicates to linters that a long line should be permitted</p> </li> </ul> <p>Example:</p> <pre><code>&gt;&gt;&gt; print(\n...     suffix_long_lines(\n...         \"A short line...\\n\"\n...         \"Lorem ipsum dolor sit amet, consectetur adipiscing \"\n...         \"elit. Nullam faucibu odio a urna elementum, eu tempor \"\n...         \"nisl efficitur.\\n\"\n...         \"...another short line\"\n...     )\n... )\nA short line...\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam faucibu odio a urna elementum, eu tempor nisl efficitur.\n...another short line\n</code></pre> Source code in <code>src/sob/utilities.py</code> <pre><code>def suffix_long_lines(\n    text: str,\n    max_line_length: int = MAX_LINE_LENGTH,\n    suffix: str = \"  # noqa: E501\",\n) -&gt; str:\n    \"\"\"\n    This function adds a suffix to the end of any line of code longer than\n    `max_line_length`.\n\n    Parameters:\n        text: Text representing python code\n        max_line_length:\n            The length at which a line should have the `suffix` appended. If\n            this is a *negative* integer (or zero), the sum of this integer +\n            `MAX_LINE_LENGTH` is used\n        suffix: The default suffix indicates to linters that\n            a long line should be permitted\n\n    Example:\n\n        &gt;&gt;&gt; print(\n        ...     suffix_long_lines(\n        ...         \"A short line...\\\\n\"\n        ...         \"Lorem ipsum dolor sit amet, consectetur adipiscing \"\n        ...         \"elit. Nullam faucibu odio a urna elementum, eu tempor \"\n        ...         \"nisl efficitur.\\\\n\"\n        ...         \"...another short line\"\n        ...     )\n        ... )\n        A short line...\n        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam faucibu odio a urna elementum, eu tempor nisl efficitur.\n        ...another short line\n\n    \"\"\"  # noqa: E501\n    return \"\\n\".join(\n        _iter_suffix_long_lines(\n            text, max_line_length=max_line_length, suffix=suffix\n        )\n    )\n</code></pre>"},{"location":"api/utilities/#sob.utilities.iter_properties_values","title":"iter_properties_values","text":"<pre><code>iter_properties_values(\n    object_: object, *, include_private: bool = False\n) -&gt; collections.abc.Iterable[tuple[str, typing.Any]]\n</code></pre> <p>This function iterates over an object's public (non-callable) properties, yielding a tuple comprised of each attribute/property name and value.</p> <p>Parameters:</p> <ul> <li> <code>object_</code>               (<code>object</code>)           \u2013            </li> <li> <code>include_private</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If this is <code>True</code>, private properties (those starting with an underscore) will be included in the iteration.</p> </li> </ul> Source code in <code>src/sob/utilities.py</code> <pre><code>def iter_properties_values(\n    object_: object, *, include_private: bool = False\n) -&gt; Iterable[tuple[str, Any]]:\n    \"\"\"\n    This function iterates over an object's public (non-callable)\n    properties, yielding a tuple comprised of each attribute/property name and\n    value.\n\n    Parameters:\n        object_:\n        include_private: If this is `True`, private properties (those\n            starting with an underscore) will be included in the iteration.\n    \"\"\"\n    names: Iterable[str] = dir(object_)\n    if not include_private:\n        names = filter(_is_public, names)\n\n    def get_name_value(name: str) -&gt; tuple[str, str] | None:\n        value: Any = getattr(object_, name, lambda: None)\n        if callable(value):\n            return None\n        return name, value\n\n    return filter(None, map(get_name_value, names))\n</code></pre>"},{"location":"api/utilities/#sob.utilities.get_qualified_name","title":"get_qualified_name","text":"<pre><code>get_qualified_name(\n    type_or_module: (\n        type | typing.Callable | types.ModuleType\n    ),\n) -&gt; str\n</code></pre> <p>This function return the fully qualified name for a type or module.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; print(get_qualified_name(get_qualified_name))\nsob.utilities.get_qualified_name\n\n&gt;&gt;&gt; from sob import model\n&gt;&gt;&gt; print(get_qualified_name(model.marshal))\nsob.model.marshal\n</code></pre> Source code in <code>src/sob/utilities.py</code> <pre><code>def get_qualified_name(type_or_module: type | Callable | ModuleType) -&gt; str:\n    \"\"\"\n    This function return the fully qualified name for a type or module.\n\n    Examples:\n\n        &gt;&gt;&gt; print(get_qualified_name(get_qualified_name))\n        sob.utilities.get_qualified_name\n\n        &gt;&gt;&gt; from sob import model\n        &gt;&gt;&gt; print(get_qualified_name(model.marshal))\n        sob.model.marshal\n    \"\"\"\n    if not isinstance(type_or_module, QUALIFIED_NAME_ARGUMENT_TYPES):\n        raise TypeError(type_or_module)\n    type_name: str\n    if isinstance(type_or_module, ModuleType):\n        type_name = type_or_module.__name__\n    else:\n        type_name = getattr(\n            type_or_module,\n            \"__qualname__\",\n            getattr(type_or_module, \"__name__\", \"\"),\n        )\n        if \"&lt;\" in type_name:\n            name_part: str\n            type_name = \".\".join(\n                filter(\n                    lambda name_part: not name_part.startswith(\"&lt;\"),\n                    type_name.split(\".\"),\n                )\n            )\n        if (not type_name) and hasattr(type_or_module, \"__origin__\"):\n            # If this is a generic alias, we can use `repr`\n            # to get the qualified type name\n            type_name = repr(type_or_module)\n        if not type_name:\n            msg = (\n                \"A qualified type name could not be inferred for \"\n                f\"`{type_or_module!r}` \"\n                f\"(an instance of {type(type_or_module).__name__})\"\n            )\n            raise TypeError(msg)\n        if type_or_module.__module__ not in (\n            \"builtins\",\n            \"__builtin__\",\n            \"__main__\",\n            \"__init__\",\n        ):\n            type_name = type_or_module.__module__ + \".\" + type_name\n    return type_name\n</code></pre>"},{"location":"api/utilities/#sob.utilities.get_calling_module_name","title":"get_calling_module_name","text":"<pre><code>get_calling_module_name(depth: int = 1) -&gt; str\n</code></pre> <p>This function returns the name of the module from which the function which invokes this function was called.</p> <p>Parameters:</p> <ul> <li> <code>depth</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>This defaults to <code>1</code>, indicating we want to return the name of the module wherein <code>get_calling_module_name</code> is being called. If set to <code>2</code>, it would instead indicate the module.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; print(get_calling_module_name())\nsob.utilities\n\n&gt;&gt;&gt; print(get_calling_module_name(2))\ndoctest\n</code></pre> Source code in <code>src/sob/utilities.py</code> <pre><code>def get_calling_module_name(depth: int = 1) -&gt; str:\n    \"\"\"\n    This function returns the name of the module from which the function\n    which invokes this function was called.\n\n    Parameters:\n        depth: This defaults to `1`, indicating we want to return the name\n            of the module wherein `get_calling_module_name` is being called.\n            If set to `2`, it would instead indicate the module.\n\n    Examples:\n\n        &gt;&gt;&gt; print(get_calling_module_name())\n        sob.utilities\n\n        &gt;&gt;&gt; print(get_calling_module_name(2))\n        doctest\n    \"\"\"\n    name: str\n    try:\n        name = sys._getframe(depth).f_globals.get(  # noqa: SLF001\n            \"__name__\", \"__main__\"\n        )\n    except (AttributeError, ValueError):\n        name = \"__main__\"\n    return name\n</code></pre>"},{"location":"api/utilities/#sob.utilities.get_calling_function_qualified_name","title":"get_calling_function_qualified_name","text":"<pre><code>get_calling_function_qualified_name(\n    depth: int = 1,\n) -&gt; str | None\n</code></pre> <p>Return the fully qualified name of the function from within which this is being called</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def my_function() -&gt; str:\n...     return get_calling_function_qualified_name()\n&gt;&gt;&gt; print(my_function())\nsob.utilities.my_function\n\n&gt;&gt;&gt; class MyClass:\n...     def __call__(self) -&gt; None:\n...         return self.my_method()\n...\n...     def my_method(self) -&gt; str:\n...         return get_calling_function_qualified_name()\n&gt;&gt;&gt; print(MyClass()())\nsob.utilities.MyClass.my_method\n</code></pre> Source code in <code>src/sob/utilities.py</code> <pre><code>def get_calling_function_qualified_name(depth: int = 1) -&gt; str | None:\n    \"\"\"\n    Return the fully qualified name of the function from within which this is\n    being called\n\n    Examples:\n\n        &gt;&gt;&gt; def my_function() -&gt; str:\n        ...     return get_calling_function_qualified_name()\n        &gt;&gt;&gt; print(my_function())\n        sob.utilities.my_function\n\n        &gt;&gt;&gt; class MyClass:\n        ...     def __call__(self) -&gt; None:\n        ...         return self.my_method()\n        ...\n        ...     def my_method(self) -&gt; str:\n        ...         return get_calling_function_qualified_name()\n        &gt;&gt;&gt; print(MyClass()())\n        sob.utilities.MyClass.my_method\n    \"\"\"\n    if not isinstance(depth, int):\n        raise TypeError(depth)\n    try:\n        stack_ = stack()\n    except IndexError:\n        return None\n    if len(stack_) &lt; (depth + 1):\n        return None\n    return \".\".join(reversed(tuple(_iter_frame_info_names(stack_[depth]))))\n</code></pre>"},{"location":"api/utilities/#sob.utilities.get_source","title":"get_source","text":"<pre><code>get_source(\n    object_: type | typing.Callable | types.ModuleType,\n) -&gt; str\n</code></pre> <p>Get the source code which defined an object.</p> Source code in <code>src/sob/utilities.py</code> <pre><code>def get_source(object_: type | Callable | ModuleType) -&gt; str:\n    \"\"\"\n    Get the source code which defined an object.\n    \"\"\"\n    object_source: str = getattr(object_, \"_source\", \"\")\n    if not object_source:\n        object_source = getsource(object_)\n    return object_source\n</code></pre>"},{"location":"api/utilities/#sob.utilities.represent","title":"represent","text":"<pre><code>represent(value: typing.Any) -&gt; str\n</code></pre> <p>Returns a string representation of a value, formatted to minimize character width, and utilizing fully qualified class/function names (including module) where applicable.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>typing.Any</code>)           \u2013            </li> </ul> Source code in <code>src/sob/utilities.py</code> <pre><code>def represent(value: Any) -&gt; str:\n    \"\"\"\n    Returns a string representation of a value, formatted to minimize\n    character width, and utilizing fully qualified class/function names\n    (including module) where applicable.\n\n    Parameters:\n        value:\n    \"\"\"\n    value_representation: str\n    if isinstance(value, type):\n        value_representation = get_qualified_name(value)\n    else:\n        value_type: type = type(value)\n        if value_type is list:\n            value_representation = _repr_list(value)\n        elif value_type is tuple:\n            value_representation = _repr_tuple(value)\n        elif value_type is set:\n            value_representation = _repr_set(value)\n        elif value_type is dict:\n            value_representation = _repr_dict(value)\n        else:\n            value_representation = repr(value)\n            if (\n                value_type is str\n                and '\"' not in value_representation\n                and value_representation.startswith(\"'\")\n                and value_representation.endswith(\"'\")\n            ):\n                value_representation = f'\"{value_representation[1:-1]}\"'\n    return value_representation\n</code></pre>"},{"location":"api/utilities/#sob.utilities.get_method","title":"get_method","text":"<pre><code>get_method(\n    object_instance: object,\n    method_name: str,\n    default: (\n        typing.Callable | sob._types.Undefined | None\n    ) = sob._types.UNDEFINED,\n) -&gt; typing.Callable[..., typing.Any] | None\n</code></pre> <p>This function attempts to retrieve an object's method, by name, if the method exists. If the object does not have a method with the given name, this function returns the <code>defualt</code> function (if provided), otherwise <code>None</code>.</p> <p>Parameters:</p> <ul> <li> <code>object_instance</code>               (<code>object</code>)           \u2013            </li> <li> <code>method_name</code>               (<code>str</code>)           \u2013            </li> <li> <code>default</code>               (<code>typing.Callable | sob._types.Undefined | None</code>, default:                   <code>sob._types.UNDEFINED</code> )           \u2013            </li> </ul> Source code in <code>src/sob/utilities.py</code> <pre><code>def get_method(\n    object_instance: object,\n    method_name: str,\n    default: Callable | Undefined | None = UNDEFINED,\n) -&gt; Callable[..., Any] | None:\n    \"\"\"\n    This function attempts to retrieve an object's method, by name, if the\n    method exists. If the object does not have a method with the given name,\n    this function returns the `defualt` function (if provided), otherwise\n    `None`.\n\n    Parameters:\n        object_instance:\n        method_name:\n        default:\n    \"\"\"\n    method: Callable\n    try:\n        method = getattr(object_instance, method_name)\n    except AttributeError:\n        if isinstance(default, Undefined):\n            raise\n        return default\n    if callable(method):\n        return method\n    if isinstance(default, Undefined):\n        message: str = (\n            f\"{get_qualified_name(type(object_instance))}.{method_name} \"\n            \"is not callable.\"\n        )\n        raise AttributeError(message)  # noqa: TRY004\n    return method\n</code></pre>"},{"location":"api/version/","title":"sob.version","text":""},{"location":"api/version/#sob.version","title":"sob.version","text":""},{"location":"api/version/#sob.version.Version","title":"Version","text":"<pre><code>Version(\n    version_string: str | None = None,\n    specification: str = \"\",\n    compatible_with: (\n        collections.abc.Sequence[\n            str | int | float | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    equals: (\n        collections.abc.Sequence[\n            str | int | float | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    exactly_equals: (\n        collections.abc.Sequence[\n            str | int | float | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    not_equals: (\n        collections.abc.Sequence[\n            str | int | float | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    less_than: (\n        collections.abc.Sequence[\n            str | int | float | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    less_than_or_equal_to: (\n        collections.abc.Sequence[\n            str | int | float | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    greater_than: (\n        collections.abc.Sequence[\n            str | int | float | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    greater_than_or_equal_to: (\n        collections.abc.Sequence[\n            str | int | float | decimal.Decimal\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Version</code></p> <p>Instances of this class represent specification version compatibility.</p> <p>An instance of <code>sob.Version</code> can be initialized from a version string formatted similarly to python package dependency specifiers as documented in PEP-440, but instead of representing package version compatibility, it represents compatibility with a specification version.</p> <p>Attributes:</p> <ul> <li> <code>specification</code>           \u2013            <p>A specification name/identifier. This can be any string, so long as the same string is used when representing versions in property metadata as when applying the version using <code>sob.version_model</code>.</p> </li> <li> <code>compatible_with</code>           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>~=</code> in PEP-440.</p> </li> <li> <code>equals</code>           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>==</code> in PEP-440.</p> </li> <li> <code>exactly_equals</code>           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>===</code> in PEP-440.</p> </li> <li> <code>not_equals</code>           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>!=</code> in PEP-440.</p> </li> <li> <code>less_than</code>           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>&lt;</code> in PEP-440.</p> </li> <li> <code>less_than_or_equal_to</code>           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>&lt;=</code> in PEP-440.</p> </li> <li> <code>greater_than</code>           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>&gt;</code> in PEP-440.</p> </li> <li> <code>greater_than_or_equal_to</code>           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>&gt;=</code> in PEP-440.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>version_string</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A version string formatted similarly to python package dependency specifiers as documented in PEP-440.</p> </li> <li> <code>specification</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>A specification name/identifier. This can be any string, so long as the same string is used when representing versions in property metadata as when applying the version using <code>sob.version_model</code>.</p> </li> <li> <code>compatible_with</code>               (<code>collections.abc.Sequence[str | int | float | decimal.Decimal] | None</code>, default:                   <code>None</code> )           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>~=</code> in PEP-440.</p> </li> <li> <code>equals</code>               (<code>collections.abc.Sequence[str | int | float | decimal.Decimal] | None</code>, default:                   <code>None</code> )           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>==</code> in PEP-440.</p> </li> <li> <code>exactly_equals</code>               (<code>collections.abc.Sequence[str | int | float | decimal.Decimal] | None</code>, default:                   <code>None</code> )           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>===</code> in PEP-440.</p> </li> <li> <code>not_equals</code>               (<code>collections.abc.Sequence[str | int | float | decimal.Decimal] | None</code>, default:                   <code>None</code> )           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>!=</code> in PEP-440.</p> </li> <li> <code>less_than</code>               (<code>collections.abc.Sequence[str | int | float | decimal.Decimal] | None</code>, default:                   <code>None</code> )           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>&lt;</code> in PEP-440.</p> </li> <li> <code>less_than_or_equal_to</code>               (<code>collections.abc.Sequence[str | int | float | decimal.Decimal] | None</code>, default:                   <code>None</code> )           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>&lt;=</code> in PEP-440.</p> </li> <li> <code>greater_than</code>               (<code>collections.abc.Sequence[str | int | float | decimal.Decimal] | None</code>, default:                   <code>None</code> )           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>&gt;</code> in PEP-440.</p> </li> <li> <code>greater_than_or_equal_to</code>               (<code>collections.abc.Sequence[str | int | float | decimal.Decimal] | None</code>, default:                   <code>None</code> )           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>&gt;=</code> in PEP-440.</p> </li> </ul> Source code in <code>src/sob/version.py</code> <pre><code>def __init__(\n    self,\n    version_string: str | None = None,\n    specification: str = \"\",\n    compatible_with: Sequence[str | int | float | Decimal] | None = None,\n    equals: Sequence[str | int | float | Decimal] | None = None,\n    exactly_equals: Sequence[str | int | float | Decimal] | None = None,\n    not_equals: Sequence[str | int | float | Decimal] | None = None,\n    less_than: Sequence[str | int | float | Decimal] | None = None,\n    less_than_or_equal_to: Sequence[str | int | float | Decimal]\n    | None = None,\n    greater_than: Sequence[str | int | float | Decimal] | None = None,\n    greater_than_or_equal_to: Sequence[str | int | float | Decimal]\n    | None = None,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        version_string: A version string formatted similarly to python\n            package dependency specifiers as documented in\n            [PEP-440](https://www.python.org/dev/peps/pep-0440).\n        specification: A specification name/identifier. This can be any\n            string, so long as the same string is used when representing\n            versions in property metadata as when applying the version\n            using `sob.version_model`.\n        compatible_with: A sequence of version numbers for which\n            comparisons should be evaluated as described for `~=` in\n            [PEP-440](https://www.python.org/dev/peps/pep-0440).\n        equals: A sequence of version numbers for which comparisons\n            should be evaluated as described for `==` in\n            [PEP-440](https://www.python.org/dev/peps/pep-0440).\n        exactly_equals: A sequence of version numbers for which comparisons\n            should be evaluated as described for `===` in\n            [PEP-440](https://www.python.org/dev/peps/pep-0440).\n        not_equals: A sequence of version numbers for which comparisons\n            should be evaluated as described for `!=` in\n            [PEP-440](https://www.python.org/dev/peps/pep-0440).\n        less_than: A sequence of version numbers for which comparisons\n            should be evaluated as described for `&lt;` in\n            [PEP-440](https://www.python.org/dev/peps/pep-0440).\n        less_than_or_equal_to: A sequence of version numbers for which\n            comparisons should be evaluated as described for `&lt;=` in\n            [PEP-440](https://www.python.org/dev/peps/pep-0440).\n        greater_than: A sequence of version numbers for which\n            comparisons should be evaluated as described for `&gt;` in\n            [PEP-440](https://www.python.org/dev/peps/pep-0440).\n        greater_than_or_equal_to:  A sequence of version numbers for which\n            comparisons should be evaluated as described for `&gt;=` in\n            [PEP-440](https://www.python.org/dev/peps/pep-0440).\n    \"\"\"\n    self.specification = specification\n    self.compatible_with = compatible_with\n    self.exactly_equals = exactly_equals\n    self.equals = equals\n    self.not_equals = not_equals\n    self.less_than = less_than\n    self.less_than_or_equal_to = less_than_or_equal_to\n    self.greater_than = greater_than\n    self.greater_than_or_equal_to = greater_than_or_equal_to\n    if version_string is not None:\n        if not isinstance(version_string, str):\n            raise TypeError(version_string)\n        self._update_version_parameters_from_string(version_string)\n</code></pre>"}]}